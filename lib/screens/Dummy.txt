import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/localdb/customersqlitehelper.dart';
import 'package:rcspos/screens/CreditCustomersPage.dart';
import 'package:rcspos/screens/createcustomer.dart';
import 'package:rcspos/screens/editcustomer.dart'; // Ensure this exists and expects a 'Customer' object
import 'package:rcspos/utils/urls.dart';
import 'package:flutter/services.dart';

// Assuming baseurl is defined in urls.dart
// const String baseurl = 'YOUR_BASE_URL';

// Define _headerStyle here (as it was referenced but not defined)
const TextStyle _headerStyle = TextStyle(
  fontFamily: "Arial",
  fontWeight: FontWeight.w500,
  fontSize: 16,
  color: Colors.white,
);

class Customer {
  final int id;
  final String name;
  final String? email;
  final String? phone;
  final String contactAddress;
  final String companyType;

  Customer({
    required this.id,
    required this.name,
    this.email,
    this.phone,
    required this.contactAddress,
    required this.companyType,
  });

  factory Customer.fromJson(Map<String, dynamic> json) {
    return Customer(
      id: json['id'],
      name: json['name'] ?? '',
      email: json['email'] == false ? null : json['email'],
      phone: json['phone'] == false ? null : json['phone'],
      contactAddress: (json['contact_address'] == false || json['contact_address'] == null) ? '' : json['contact_address'].toString(),
      companyType: (json['company_type'] == false || json['company_type'] == null) ? 'person' : json['company_type'].toString(), // Default to 'person'
    );
  }

  // No need for toMap() if EditCustomerPage directly accepts Customer object
  // But if it does, ensure it correctly handles the keys.
}

class CustomerPage extends StatefulWidget {
  const CustomerPage({Key? key}) : super(key: key);

  @override
  State<CustomerPage> createState() => _CustomerPageState();
}

class _CustomerPageState extends State<CustomerPage> {
  List<Customer> customers = []; // All customers fetched from network/DB
  // For DataRows, we use _selectedCustomerIds (Set) for multi-selection.
  // _selectedCustomerId is not strictly needed for DataTable's `selected` property.
  // Keeping it as null implies no single selection, which works with the Set.
  int? _selectedCustomerId; 
  final Set<int> _selectedCustomerIds = {}; // For multi-selection checkboxes

  // Pagination & Sorting state
  int rowsPerPage = 10;
  int currentPage = 0;
  int? _sortColumnIndex;
  bool _sortAscending = true;

  // Filtering state
  String _searchQuery = '';
  String _companyFilter = 'all';

  // Loading state
  bool isLoading = false;

  // Scroll Controllers (removed redundant _scrollController, DataTables usually handle their own scrolling within Expanded/SingleChildScrollViews)
  // No explicit sync needed for DataColumn / DataRow horizontal scrolls as they are part of the same table
  final ScrollController _verticalTableScrollController = ScrollController();


  @override
  void initState() {
    super.initState();
    fetchCustomers();
  }

  @override
  void dispose() {
    _verticalTableScrollController.dispose();
    super.dispose();
  }

  final Customersqlitehelper customerDbHelper = Customersqlitehelper();

Future<void> fetchCustomers() async {
  setState(() {
    isLoading = true;
    _selectedCustomerIds.clear();
    _selectedCustomerId = null;
  });

  final box = await Hive.openBox('login');
  final rawSession = box.get('session_id');

  if (rawSession == null) {
    setState(() => isLoading = false);
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Session not found. Please log in again.', style: TextStyle(fontFamily: 'Arial')),
      ),
    );
    return;
  }

  await customerDbHelper.init();
  final sessionId = rawSession.contains('session_id=') ? rawSession : 'session_id=$rawSession';
  final url = Uri.parse('$baseurl/api/res.partner?query={id,name,email,phone,contact_address,company_type}&filter=[["customer_rank",">=",0]]');

  try {
    final response = await http.get(url, headers: {
      HttpHeaders.cookieHeader: sessionId,
      HttpHeaders.contentTypeHeader: 'application/json',
    });

    if (response.statusCode == 200) {
      final result = json.decode(response.body)['result'];
      final List<Map<String, dynamic>> rawList = List<Map<String, dynamic>>.from(result);

      // Insert into local DB
      await customerDbHelper.insertCustomers(rawList);

      // Fetch again from local DB to ensure consistency
      final localData = await customerDbHelper.fetchCustomers();
      setState(() {
        customers = localData.map((e) => Customer.fromJson(e)).toList();
        currentPage = 0;
        _sortColumnIndex = null;
        _sortAscending = true;
      });
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to load customers: ${response.body}', style: const TextStyle(fontFamily: 'Arial')),
          backgroundColor: Colors.red,
        ),
      );
    }
  } catch (e) {
    debugPrint("Network error while fetching customers: $e");

    final fallback = await customerDbHelper.fetchCustomers();
    if (fallback.isNotEmpty) {
      setState(() {
        customers = fallback.map((e) => Customer.fromJson(e)).toList();
        currentPage = 0;
        _sortColumnIndex = null;
        _sortAscending = true;
      });
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Network error: $e', style: const TextStyle(fontFamily: 'Arial')),
          backgroundColor: Colors.red,
        ),
      );
    }
  } finally {
    setState(() => isLoading = false);
  }
}

  void _onSort(int columnIndex, bool ascending) {
    setState(() {
      _sortColumnIndex = columnIndex;
      _sortAscending = ascending;
      currentPage = 0; // Reset pagination when sorting
      _selectedCustomerIds.clear(); // Clear selections on sort change
      _selectedCustomerId = null; // Clear single selection
    });
  }

  void _downloadAsPDF() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Downloading as PDF...', style: TextStyle(fontFamily: 'Arial'))),
    );
    debugPrint("Download as PDF tapped");
    // TODO: Implement actual PDF generation
  }

  void _downloadAsExcel() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Downloading as Excel...', style: TextStyle(fontFamily: 'Arial'))),
    );
    debugPrint("Download as Excel tapped");
    // TODO: Implement actual Excel generation
  }

  void _showDownloadOptions() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Download as', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.picture_as_pdf, color: Color.fromARGB(255, 1, 129, 91)),
                title: const Text('PDF', style: TextStyle(fontFamily: 'Arial')),
                onTap: () {
                  Navigator.pop(context); // close dialog
                  _downloadAsPDF(); // call your PDF logic
                },
              ),
              ListTile(
                leading: const Icon(Icons.grid_on, color: Color.fromARGB(255, 1, 129, 91)),
                title: const Text('Excel', style: TextStyle(fontFamily: 'Arial')),
                onTap: () {
                  Navigator.pop(context);
                  _downloadAsExcel(); // call your Excel logic
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _confirmDeleteCustomer(Customer customer) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Confirm Deletion', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
        content: Text('Are you sure you want to delete ${customer.name}?', style: const TextStyle(fontFamily: 'Arial')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            style: TextButton.styleFrom(
              foregroundColor: Colors.grey[700],
              textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16),
            ),
            child: const Text('Cancel', style: TextStyle(fontFamily: 'Arial')),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx); // Close dialog
              await _deleteCustomer(customer.id); // Call delete API
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
              textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16, fontWeight: FontWeight.bold),
            ),
            child: const Text('Delete', style: TextStyle(fontFamily: 'Arial')),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteCustomer(int customerId) async {
    final box = await Hive.openBox('login');
    final rawSession = box.get('session_id');
    if (rawSession == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Session not found.', style: TextStyle(fontFamily: 'Arial'))),
      );
      return;
    }
    final sessionId = rawSession.contains('session_id=') ? rawSession : 'session_id=$rawSession';

    final url = Uri.parse('$baseurl/mobile/delete_customer/$customerId');
    try {
      final response = await http.delete(
        url,
        headers: {
          HttpHeaders.cookieHeader: sessionId,
          HttpHeaders.contentTypeHeader: 'application/json',
        },
      );

      if (response.statusCode == 200) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Customer deleted successfully!', style: TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.green),
        );
        fetchCustomers(); // Refresh the list
      } else {
        final error = json.decode(response.body)['error']['message'] ?? 'Unknown error';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to delete customer: $error', style: const TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.red),
        );
        debugPrint('Error response: ${response.body}');
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('An error occurred: $e', style: const TextStyle(fontFamily: 'Arial'))),
      );
      debugPrint('Exception during customer deletion: $e');
    }
  }

  void _startPaymentProcessForSelectedCustomers() {
    if (_selectedCustomerIds.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select at least one customer to process payment.', style: TextStyle(fontFamily: 'Arial'))),
      );
      return;
    }

    final List<Customer> customersToProcess = customers
        .where((customer) => _selectedCustomerIds.contains(customer.id))
        .toList();

    debugPrint('Initiating payment process for customer IDs: ${_selectedCustomerIds.toList()}');

    if (customersToProcess.isNotEmpty) {
      // Assuming you want to return the first selected customer's data to the previous screen
      Navigator.pop(context, {
        'id': customersToProcess.first.id,
        'name': customersToProcess.first.name,
        'email': customersToProcess.first.email,
        'phone': customersToProcess.first.phone,
      });
    } else {
       ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No selected customer found.', style: TextStyle(fontFamily: 'Arial'))),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
        final double screenWidth = MediaQuery.of(context).size.width;
    final bool isMobile = screenWidth < 600; 
    // 1. Filtering Logic
    final filteredCustomers = customers.where((c) {
      final lowerCaseSearchQuery = _searchQuery.toLowerCase();
      final matchesSearch = c.name.toLowerCase().contains(lowerCaseSearchQuery) ||
          (c.email ?? '').toLowerCase().contains(lowerCaseSearchQuery) ||
          (c.phone ?? '').toLowerCase().contains(lowerCaseSearchQuery) ||
          c.contactAddress.toLowerCase().contains(lowerCaseSearchQuery) ||
          c.companyType.toLowerCase().contains(lowerCaseSearchQuery);

      final matchesType = _companyFilter == 'all' || c.companyType == _companyFilter;

      return matchesSearch && matchesType;
    }).toList(); // <--- Important: .toList() creates a new mutable list

    // 2. Sorting Logic (APPLY HERE, AFTER FILTERING)
    if (_sortColumnIndex != null) {
      filteredCustomers.sort((a, b) { // Sort the filtered list
        Comparable aValue, bValue;
        switch (_sortColumnIndex) {
          case 0: // S.No column (not sortable, this case is likely for the actual DataColumn index, not internal data index)
            return 0; // Or better, adjust _onSort's columnIndex to skip this
          case 1: // Name (Adjusted index based on DataColumn setup: S.No is 0, Name is 1 if checkbox is removed)
            aValue = a.name.toLowerCase();
            bValue = b.name.toLowerCase();
            break;
          case 2: // Email (Adjusted index)
            aValue = (a.email ?? '').toLowerCase();
            bValue = (b.email ?? '').toLowerCase();
            break;
          case 3: // Phone (Adjusted index)
            aValue = (a.phone ?? '').toLowerCase();
            bValue = (b.phone ?? '').toLowerCase();
            break;
          case 4: // Address (Adjusted index)
            aValue = a.contactAddress.toLowerCase();
            bValue = b.contactAddress.toLowerCase();
            break;
          case 5: // Company Type (Adjusted index)
            aValue = a.companyType.toLowerCase();
            bValue = b.companyType.toLowerCase();
            break;
          default:
            return 0; // For Actions, no sorting
        }
        return _sortAscending ? Comparable.compare(aValue, bValue) : Comparable.compare(bValue, aValue);
      });
    }
    

    // 3. Pagination Logic (applied AFTER filtering and sorting)
    final totalFilteredCustomers = filteredCustomers.length;
    final totalPages = (totalFilteredCustomers / rowsPerPage).ceil();
    final startIndex = currentPage * rowsPerPage;
    final endIndex = (startIndex + rowsPerPage).clamp(0, totalFilteredCustomers);
    final visibleCustomers = filteredCustomers.sublist(startIndex, endIndex);


    // 3. Pagination Logic (applied AFTER filtering and sorting)
    // final totalFilteredCustomers = filteredCustomers.length;
    // final totalPages = (totalFilteredCustomers / rowsPerPage).ceil();
    // final startIndex = currentPage * rowsPerPage;
    // final endIndex = (startIndex + rowsPerPage).clamp(0, totalFilteredCustomers);
    // final visibleCustomers = filteredCustomers.sublist(startIndex, endIndex);

    // Determine if all visible customers are selected for the header checkbox
    final bool allVisibleCustomersSelected =
        visibleCustomers.isNotEmpty && visibleCustomers.every((customer) => _selectedCustomerIds.contains(customer.id));

    return Scaffold(
  appBar: PreferredSize(
        // Adjust preferred height to potentially accommodate a wrapped row on small screens
        preferredSize: Size.fromHeight(isMobile ? 180 : 120),
        child: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          automaticallyImplyLeading: false,
          flexibleSpace: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color.fromARGB(255, 44, 145, 113), Color(0xFF185A9D)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
            child: SafeArea(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        GestureDetector(
                          onTap: () {
                            Navigator.pop(context);
                          },
                          child: Row(
                            children: const [
                              Icon(Icons.arrow_back, color: Colors.white, size: 24),
                              SizedBox(width: 8),
                              Text(
                                'Customer Table',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontSize: 20,
                                  fontFamily: 'Arial',
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                        // Always keep these two in a Row (or Wrap for potential overflow)
                        Flexible( // Use Flexible to allow the Wrap to take available space
                          child: Wrap( // Wrap will put items on the next line if space is limited
                            spacing: 10, // Space between dropdown and button
                            runSpacing: 10, // Space between lines if they wrap
                            alignment: WrapAlignment.end, // Align to the end of the row
                            children: [
                              _buildCompanyFilterDropdown(),
                              _buildCreditCustomersButton(),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 10),
                    Container(
                      height: 40,
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(28),
                      ),
                      child: TextField(
                        onChanged: (value) {
                          setState(() {
                            _searchQuery = value;
                            currentPage = 0; // Reset pagination on search change
                            _selectedCustomerIds.clear(); // Clear selections on search change
                          });
                        },
                        decoration: const InputDecoration(
                          hintText: 'Search customers...',
                          hintStyle: TextStyle(color: Colors.grey, fontFamily: 'Arial'),
                          border: InputBorder.none,
                          prefixIcon: Icon(Icons.search, color: Colors.grey),
                          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        ),
                        style: const TextStyle(fontSize: 16, fontFamily: 'Arial', color: Colors.black87),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
           body: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color.fromARGB(255, 1, 129, 91)))
          : Padding(
              padding: const EdgeInsets.symmetric(horizontal: 0.0), // Padding for the whole content
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 16),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Wrap(
                        spacing: 12,
                        runSpacing: 12,
                        children: [
ElevatedButton.icon(
  onPressed: () async {
    final result = await showDialog<bool>(
      context: context,
      barrierColor: Colors.black.withAlpha((0.5 * 255).toInt()),
      builder: (ctx) => const CreateCustomerPage(),
    );

    if (result == true) {
      await customerDbHelper.init();
      final localData = await customerDbHelper.fetchCustomers();
      setState(() {
        customers = localData.map((e) => Customer.fromJson(e)).toList();
        currentPage = 0;
        _sortColumnIndex = null;
        _sortAscending = true;
      });
    }
  },
  style: ElevatedButton.styleFrom(
    backgroundColor: const Color.fromARGB(255, 201, 202, 201),
    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 8),
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
  ),
  icon: const Icon(Icons.add, color: Colors.black),
  label: const Text(
    'ADD CUSTOMER',
    style: TextStyle(
      color: Colors.black,
      fontFamily: 'Arial',
      fontSize: 13,
      fontWeight: FontWeight.w600,
    ),
  ),
),

                          // Payment Process Button
                          if (_selectedCustomerIds.isNotEmpty)
                            ElevatedButton.icon(
                              onPressed: _startPaymentProcessForSelectedCustomers,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: const Color.fromARGB(255, 1, 129, 91),
                                padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                              ),
                              icon: const Icon(Icons.payment, color: Colors.white),
                              label: const Text(
                                'Done',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontFamily: 'Arial',
                                  fontSize: 14,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ),

                          // Download Button
                          ElevatedButton.icon(
                            onPressed: _showDownloadOptions,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.blueGrey[700],
                              padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 10),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                            ),
                            icon: const Icon(Icons.download, color: Colors.white),
                            label: const Text(
                              'DOWNLOAD',
                              style: TextStyle(
                                color: Colors.white,
                                fontFamily: 'Arial',
                                fontSize: 13,
                              ),
                            ),
                          ),
                        ],
                      )
                    ],
                  ),
                  const SizedBox(height: 16),
                  if (visibleCustomers.isEmpty)
                    Expanded(
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.person_off, size: 48, color: Colors.grey[400]),
                            const SizedBox(height: 8),
                            Text(
                              _searchQuery.isNotEmpty || _companyFilter != 'all'
                                  ? 'No customers match your criteria.'
                                  : 'No customers found.',
                              style: TextStyle(
                                fontSize: 16,
                                fontFamily: 'Arial',
                                color: Colors.grey[600],
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  else
                    Expanded(
                      child: SingleChildScrollView(
                        controller: _verticalTableScrollController, // Vertical scroll for the whole table content
                        scrollDirection: Axis.vertical,
                        child: SingleChildScrollView(
                          scrollDirection: Axis.horizontal,
                          child: ConstrainedBox(
                            constraints: BoxConstraints(
                              // Ensure minimum width to allow horizontal scrolling
                              minWidth: MediaQuery.of(context).size.width, // Subtract horizontal padding
                            ),
child: DataTable(
                              headingRowColor: MaterialStateProperty.resolveWith<Color>(
                                (Set<MaterialState> states) => const Color.fromARGB(255, 8, 72, 150),
                              ),
                              headingTextStyle: _headerStyle,
                              columnSpacing: 0,
                              dataRowColor: MaterialStateProperty.resolveWith<Color>((states) {
                               
                                if (states.contains(MaterialState.selected)) {
                                  return Colors.blue.withOpacity(0.2);
                                }
                                return Colors.white; // Default color
                              }),
                              sortColumnIndex: _sortColumnIndex == 0 ? null : _sortColumnIndex, // Adjust index if 0 was for checkbox
                              sortAscending: _sortAscending,
                           
                              showCheckboxColumn: false, 
                              columns: [
                        
                                DataColumn(
                                  label: SizedBox( child: const Text('S.No')),
                                
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Name')),
                                  onSort: (columnIndex, ascending) => _onSort(1, ascending), 
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Email')),
                                  onSort: (columnIndex, ascending) => _onSort(2, ascending), 
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Phone')),
                                  onSort: (columnIndex, ascending) => _onSort(3, ascending), 
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Address')),
                                  onSort: (columnIndex, ascending) => _onSort(4, ascending), 
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Company Type')),
                                  onSort: (columnIndex, ascending) => _onSort(5, ascending), 
                                ),
                                DataColumn(
                                  label: const SizedBox( child: Text('Actions')),
                                 
                                ),
                              ],
                              rows: visibleCustomers.asMap().entries.map((entry) {
                                final int index = entry.key;
                                final Customer customer = entry.value;
                                final bool isSelected = _selectedCustomerIds.contains(customer.id);

                                return DataRow(
                                  selected: isSelected, 
                            onSelectChanged: (selected) {
  setState(() {
    if (selected == true) {
      _selectedCustomerIds
        ..clear()
        ..add(customer.id);
    } else {
      _selectedCustomerIds.remove(customer.id);
    }
  });
},

                                  cells: [
                                    // DataCell for S.No
                                    DataCell(Text('${startIndex + index + 1}')),
                                    DataCell(Text(customer.name)),
                                    DataCell(Text(customer.email ?? '-')),
                                    DataCell(Text(customer.phone ?? '-')),
                                    DataCell(
  SizedBox(
    width: 200, // Adjust this width as needed
    child: Text(
      customer.contactAddress.replaceAll('\n', ', '),
      overflow: TextOverflow.ellipsis, // Optional: handle overflow with ellipsis
      maxLines: 2, // Optional: limit the number of lines
    ),
  ),
),
DataCell(Row(
  children: [
    Icon(
      customer.companyType == 'company' ? Icons.business : Icons.person,
      size: 18,
      color: customer.companyType == 'company' ? Colors.blue : Colors.green,
    ),
    const SizedBox(width: 6),
    Text(
      '${customer.companyType[0].toUpperCase()}${customer.companyType.substring(1).toLowerCase()}',
      style: const TextStyle(fontFamily: 'Arial'),
    ),
  ],
)),

                                    DataCell(
                                      Row(
                                        children: [
                                          IconButton(
                                            icon: const Icon(Icons.edit, color: Colors.blue),
                                            tooltip: 'Edit Customer',
                                           onPressed: () async {
final updatedCustomer = await showDialog(
  context: context,
  builder: (_) => EditCustomerPage(customer: customer),
);

if (updatedCustomer is Customer) {
  final index = customers.indexWhere((c) => c.id == updatedCustomer.id);
  if (index != -1) {
    setState(() {
      customers[index] = updatedCustomer;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Customer "${updatedCustomer.name}" updated.'),
        backgroundColor: Colors.green,
      ),
    );
  }
}

}
                                        
                                         ),
                                          IconButton(
                                            icon: const Icon(Icons.delete, color: Colors.red),
                                            tooltip: 'Delete Customer',
                                            onPressed: () => _confirmDeleteCustomer(customer),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ],
                                );
                              }).toList(),
                            ),                        ),
                        ),
                      ),
                    ),
                  // --- Pagination controls (Footer) ---
                  if (!isLoading && totalFilteredCustomers > 0)
                    _buildFooter(
                      totalFilteredCustomers,
                      startIndex,
                      endIndex,
                      totalPages,
                    ),
                ],
              ),
            ),
    );
  
  }

  Widget _buildFooter(int total, int start, int end, int totalPages) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: const BorderRadius.vertical(bottom: Radius.circular(8)),
        border: Border.all(color: Colors.grey.shade300, width: 1),
      ),
      child: Row(
        children: [
          Row(
            children: [
              const Text("Rows per page:", style: TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87)),
              const SizedBox(width: 8),
              DropdownButton<int>(
                value: rowsPerPage,
                items: [5, 10, 20, 50].map((e) {
                  return DropdownMenuItem(value: e, child: Text(e.toString(), style: const TextStyle(fontFamily: 'Arial')));
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      rowsPerPage = value;
                      currentPage = 0; // Reset page when rows per page changes
                      _selectedCustomerIds.clear(); // Clear selections on rows per page change
                    });
                  }
                },
                style: const TextStyle(fontFamily: 'Arial', color: Colors.black87),
                icon: const Icon(Icons.arrow_drop_down, color: Color.fromARGB(255, 1, 129, 91)),
                underline: const SizedBox(),
              ),
            ],
          ),
          const Spacer(),
          Text("${start + 1}â€“$end of $total", style: const TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87)),
          IconButton(
            icon: const Icon(Icons.chevron_left),
            onPressed: currentPage > 0
                ? () => setState(() {
                      currentPage--;
                      _selectedCustomerIds.clear(); // Clear selections on page navigation
                    })
                : null,
            color: const Color.fromARGB(255, 1, 129, 91),
            disabledColor: Colors.grey[400],
          ),
          IconButton(
            icon: const Icon(Icons.chevron_right),
            onPressed: (currentPage + 1) < totalPages
                ? () => setState(() {
                      currentPage++;
                      _selectedCustomerIds.clear(); // Clear selections on page navigation
                    })
                : null,
            color: const Color.fromARGB(255, 1, 129, 91),
            disabledColor: Colors.grey[400],
          ),
        ],
      ),
    );
  }
   Widget _buildCompanyFilterDropdown() {
    return Container(
      height: 40,
      padding: const EdgeInsets.symmetric(horizontal: 5),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: Colors.white, width: 0.8),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: _companyFilter,
          dropdownColor: Colors.white,
          icon: const Icon(Icons.arrow_drop_down, color: Colors.white, size: 24),
          selectedItemBuilder: (BuildContext context) {
            return <String>['all', 'person', 'company'].map<Widget>((String itemValue) {
              return Align(
                alignment: Alignment.centerLeft,
                child: Text(
                  itemValue.toUpperCase(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontFamily: 'Arial',
                    fontSize: 14,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              );
            }).toList();
          },
          items: const [
            DropdownMenuItem(value: 'all', child: Text('All', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
            DropdownMenuItem(value: 'person', child: Text('Person', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
            DropdownMenuItem(value: 'company', child: Text('Company', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
          ],
          onChanged: (value) {
            if (value != null) {
              setState(() {
                _companyFilter = value;
                currentPage = 0;
                _selectedCustomerIds.clear();
              });
            }
          },
        ),
      ),
    );
  }
Widget _buildCreditCustomersButton() {
    return ElevatedButton.icon(
      onPressed: () {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => const CreditCustomersPage()),
        );
      },
      style: ElevatedButton.styleFrom(
        foregroundColor: Colors.black, // Text/icon color
        backgroundColor: Colors.white, // Match dropdown background
        elevation: 0,
        side: const BorderSide(color: Colors.grey), // Match dropdown border
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6), // Slight curve like dropdown
        ),
        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 10),
        minimumSize: const Size(180, 48), // Match dropdown height
      ),
      icon: const Icon(Icons.credit_score, size: 20, color: Color.fromARGB(255, 4, 83, 63)),
      label: const Text(
        'Credit Customers',
        style: TextStyle(
          color: Color.fromARGB(255, 4, 83, 63),
          fontSize: 15,
          fontWeight: FontWeight.bold,
          fontFamily: 'Arial',
        ),
      ),
    );
  }


}
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/screens/customerpage.dart';
import 'package:rcspos/utils/urls.dart';


class EditCustomerPage extends StatefulWidget {
  final Customer customer;
  const EditCustomerPage({required this.customer, super.key});

  @override
  State<EditCustomerPage> createState() => _EditCustomerPageState();
}

class _EditCustomerPageState extends State<EditCustomerPage> {
  final _formKey = GlobalKey<FormState>(); // Form key for validation
  final nameController = TextEditingController();
  final phoneController = TextEditingController();
  final emailController = TextEditingController();
  final contactAddressController = TextEditingController(); // Renamed for consistency

  // final street2Controller = TextEditingController();
  // final cityController = TextEditingController();
  // final zipController = TextEditingController();
  final vatController = TextEditingController();

    late TextEditingController streetController;
  late TextEditingController cityController;
  late TextEditingController zipController;
  bool isLoading = false;
  String _selectedType = 'person'; 
final List<String> _districts = [
  'Ariyalur','Chengalpattu','Chennai','Coimbatore','Cuddalore','Dharmapuri','Dindigul',
  'Erode','Kallakurichi','Kancheepuram','Karur','Krishnagiri','Madurai','Nagapattinam','Namakkal','Nilgiris','Perambalur','Pudukkottai','Ramanathapuram','Ranipet','Salem','Sivaganga','Tenkasi','Thanjavur','Theni',
  'Thoothukudi','Tiruchirappalli','Tirunelveli','Tirupathur','Tiruppur','Tiruvallur','Tiruvannamalai','Tiruvarur','Vellore','Viluppuram','Virudhunagar',
];
String? _selectedDistrict;
  @override
  void initState() {
    super.initState();
    nameController.text = widget.customer.name;
    phoneController.text = widget.customer.phone ?? '';
    emailController.text = widget.customer.email ?? '';
    contactAddressController.text = widget.customer.contactAddress ?? '';

    _selectedType = widget.customer.companyType ?? 'person'; // Initialize selected type

String contactAddress = widget.customer.contactAddress;
    List<String> lines = contactAddress.split('\n').where((line) => line.trim().isNotEmpty).toList();

    String street = lines.length > 2 ? lines[2] : '';
    String cityZipLine = lines.firstWhere(
      (line) => RegExp(r'\b\d{6}\b').hasMatch(line),
      orElse: () => '',
    );

    String city = cityZipLine.split(' ').first;
    String zip = RegExp(r'\d{6}').firstMatch(cityZipLine)?.group(0) ?? '';

    // ðŸ“¥ Initialize controllers
    streetController = TextEditingController(text: street);
    cityController = TextEditingController(text: city);
    zipController = TextEditingController(text: zip);
    debugPrint('Editing customer with ID: ${widget.customer.id}');
  }

  @override
  void dispose() {
    // Dispose all controllers to prevent memory leaks
    nameController.dispose();
    phoneController.dispose();
    emailController.dispose();
    contactAddressController.dispose();
    streetController.dispose();
    cityController.dispose();
    zipController.dispose();
    vatController.dispose();
    super.dispose();
  }

  // Re-use the helper from the AddCustomerDialog for consistency
  Widget _buildTextField(
    TextEditingController controller,
    String labelText,
    IconData icon, {
    String? hintText,
    TextInputType keyboardType = TextInputType.text,
    int? maxLength,
    List<TextInputFormatter>? inputFormatters,
    String? Function(String?)? validator,
    bool required = false,
  }) {
    return TextFormField(
      controller: controller,
      keyboardType: keyboardType,
      maxLength: maxLength,
      inputFormatters: inputFormatters,
      decoration: InputDecoration(
        labelText: labelText,
        hintText: hintText,
        border: const OutlineInputBorder(),
        prefixIcon: Icon(icon),
        counterText: maxLength != null ? '' : null,
        labelStyle: const TextStyle(fontFamily: 'Arial'),
        hintStyle: const TextStyle(fontFamily: 'Arial'),
        errorStyle: const TextStyle(fontFamily: 'Arial'),
      ),
      validator: (v) {
        if (required && (v == null || v.trim().isEmpty)) {
          return '$labelText is required';
        }
        if (validator != null) {
          return validator(v);
        }
        return null;
      },
      style: const TextStyle(fontFamily: 'Arial'),
      autovalidateMode: (validator != null || required) ? AutovalidateMode.onUserInteraction : AutovalidateMode.disabled,
    );
  }

  // Helper function for building the company-specific fields (adapted for Edit dialog)
  List<Widget> _buildCompanyFields({bool isMobile = false, bool? left}) {
    List<Widget> fields = [];
    if (isMobile) {
      fields = [
        _buildTextField(contactAddressController, 'Contact Address', Icons.location_on, hintText: 'Building, Street, Area'),
        const SizedBox(height: 16),
        // _buildTextField(streetController, 'Street (optional)', Icons.meeting_room, hintText: 'Apartment, Suite, Unit, Building'),
        // const SizedBox(height: 16),
        // _buildTextField(cityController, 'City', Icons.location_city, hintText: 'e.g., Chennai'),
        // const SizedBox(height: 16),
        // _buildTextField(zipController, 'ZIP', Icons.local_post_office,
        //     keyboardType: TextInputType.number,
        //     maxLength: 6,
        //     inputFormatters: [FilteringTextInputFormatter.digitsOnly],
        //     validator: (v) => (v != null && v.trim().isNotEmpty && v.trim().length != 6) ? 'ZIP must be 6 digits' : null),
        // const SizedBox(height: 16),
        _buildTextField(vatController, 'VAT / GSTIN (optional)', Icons.confirmation_number, hintText: 'Enter VAT/GSTIN number'),
      ];
    } else {
      // Web/Wide layout (two columns)
      if (left == true) {
        fields = [
          _buildTextField(contactAddressController, 'Contact Address', Icons.location_on, hintText: 'Building, Street, Area'),
          const SizedBox(height: 16),
          // _buildTextField(cityController, 'City', Icons.location_city, hintText: 'e.g., Chennai'),
          // const SizedBox(height: 16),
        ];
      } else { // right == true
        // fields = [
        //   _buildTextField(streetController, 'Street (optional)', Icons.meeting_room, hintText: 'Apartment, Suite, Unit, Building'),
        //   const SizedBox(height: 16),
        //   _buildTextField(zipController, 'ZIP', Icons.local_post_office,
        //       keyboardType: TextInputType.number,
        //       maxLength: 6,
        //       inputFormatters: [FilteringTextInputFormatter.digitsOnly],
        //       validator: (v) => (v != null && v.trim().isNotEmpty && v.trim().length != 6) ? 'ZIP must be 6 digits' : null),
        //   const SizedBox(height: 16),
        // ];
      }
    }
    return fields;
  }

  Future<bool> _updateCustomer(int id, Map<String, dynamic> updatedData) async {
    final box = await Hive.openBox('login');
    final raw = box.get('session_id') as String?;
    final session = raw!.contains('session_id=') ? raw : 'session_id=$raw';

    final uri = Uri.parse('${baseurl}/mobile/update_customer/$id');
    final headers = {
      HttpHeaders.contentTypeHeader: 'application/x-www-form-urlencoded',
      HttpHeaders.cookieHeader: session,
    };

    final body = updatedData.map((key, value) => MapEntry(key, value?.toString() ?? ''));

    try {
      final response = await http.put(uri, headers: headers, body: body);
      debugPrint('Response status: ${response.statusCode}');
      debugPrint('Response body: ${response.body}');

      if (response.statusCode == 200) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Customer updated', style: TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.green),
        );
        return true;
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to update: ${response.body}', style: TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.red),
        );
        return false;
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: $e', style: TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.red),
      );
      return false;
    }
   finally {
  setState(() {
    isLoading = false;
  });
   }}


void _onSavePressed() async {
  if (!_formKey.currentState!.validate()) return;

  final name = nameController.text.trim();

  // Step 1: Show confirmation dialog
  final confirmed = await showDialog<bool>(
    context: context,
    builder: (ctx) => AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      title: const Text('Confirm Update', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
      content: Text(
        'Are you sure you want to update "$name"?',
        style: const TextStyle(fontFamily: 'Arial', fontSize: 15),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(ctx, false),
          child: const Text('Cancel', style: TextStyle(fontFamily: 'Arial')),
        ),
        ElevatedButton(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.green,
            foregroundColor: Colors.white,
          ),
          onPressed: () => Navigator.pop(ctx, true),
          child: const Text('Yes, Update', style: TextStyle(fontFamily: 'Arial')),
        ),
      ],
    ),
  );

  if (confirmed != true) return; // Exit if user cancels

  // Step 2: Prepare data
  final updated = {
    'name': name,
    'phone': phoneController.text.trim(),
    'email': emailController.text.trim().isNotEmpty ? emailController.text.trim() : null,
    'company_type': _selectedType,
    if (_selectedType == 'company') 'contact_address': contactAddressController.text.trim(),
  if (_selectedType == 'company') 'street2': streetController.text.trim(),
  if (_selectedType == 'company') 'city': cityController.text.trim(),
  if (_selectedType == 'company') 'zip': zipController.text.trim(),
  if (_selectedType == 'company') 'vat': vatController.text.trim(),
  };

  debugPrint('Updating customer with: $updated');

  // Step 3: Update customer
  final success = await _updateCustomer(widget.customer.id, updated);

  if (success) {
    // Show success dialog
    showDialog(
      context: context,
      barrierDismissible: false, // User must tap OK to close
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        elevation: 8.0, // Add some elevation for a subtle shadow effect
        contentPadding: const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 0.0), // Adjust content padding
        content: Column(
          mainAxisSize: MainAxisSize.min, // Make the column take minimum space
          children: [
            // Icon and Title on the same line using a Row
            Row(
              mainAxisAlignment: MainAxisAlignment.center, // Center the icon and title together
              mainAxisSize: MainAxisSize.min, // Keep the row size minimal
              children: [
                const Icon(
                  Icons.thumb_up, // The thumbs up icon
                  color: Colors.green, // Green color for success
                  size: 36, // Adjust size to fit well beside text
                ),
                const SizedBox(width: 10), // Space between icon and text
                const Text(
                  'Success!',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    fontFamily: 'Arial',
                    fontWeight: FontWeight.bold,
                    fontSize: 22, // Keep font size consistent with previous title
                    color: Colors.black87,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16), // Space between the icon/title row and the message

            // Content message
            Text(
              'Customer "$name" updated successfully!',
              textAlign: TextAlign.center, // Center align message
              style: const TextStyle(
                fontFamily: 'Arial',
                fontSize: 16, 
                color: Color.fromARGB(255, 38, 117, 41),
                fontWeight: FontWeight.w500, 
              ),
            ),
          ],
        ),
        actionsPadding: const EdgeInsets.fromLTRB(20.0, 30.0, 20.0, 20.0), 
        actions: [
          Row(
            mainAxisAlignment: MainAxisAlignment.center, 
            children: [
              ElevatedButton(
              onPressed: () {
  Navigator.of(ctx).pop(); // Close the dialog first
  Future.delayed(const Duration(milliseconds: 300), () {
   Navigator.of(context).pop(
  Customer(
    id: widget.customer.id,
    name: name,
    email: emailController.text.trim().isEmpty ? null : emailController.text.trim(),
    phone: phoneController.text.trim().isEmpty ? null : phoneController.text.trim(),
    contactAddress: contactAddressController.text.trim(),
    companyType: _selectedType,
  )
);

  });
},

                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green, 
                  foregroundColor: Colors.white, 
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12), 
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8), 
                  ),
                  elevation: 6, 
                ),
                child: const Text(
                  'OK',
                  style: TextStyle(
                    fontFamily: 'Arial',
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  } else {
    // Show failure dialog
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text('Update Failed', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
        content: const Text('Failed to update customer. Please try again.', style: TextStyle(fontFamily: 'Arial')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text('OK', style: TextStyle(fontFamily: 'Arial')),
          ),
        ],
      ),
    );
  }
}

  @override
  Widget build(BuildContext context) {
    final isMobile = MediaQuery.of(context).size.width < 600;

    return AlertDialog(
      insetPadding: const EdgeInsets.all(10),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 10,
      title: const Text(
        'Update Customer',
        textAlign: TextAlign.center,
        style: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.bold,
          color: Color.fromARGB(255, 2, 47, 88),
          fontFamily: 'Arial',
        ),
      ),
      content: Container(
        width: isMobile ? double.infinity : 650, // Consistent width
        child: SingleChildScrollView(
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 0), // Space below title

                // Customer Type - Display only (not usually editable for existing customers)
                // If it is editable, you'd need a StatefulBuilder and setState
                // For now, it's just a display, so no state change needed.
                Text(
                  'Customer Type: ${_selectedType == 'person' ? 'Person' : 'Company'}',
                  style: const TextStyle(
                    fontFamily: 'Arial',
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    color: Colors.black87,
                  ),
                  textAlign: isMobile ? TextAlign.left : TextAlign.center,
                ),
                const SizedBox(height: 10),

                // Common fields (using helper)
                _buildTextField(nameController, 'Full Name', Icons.person, hintText: 'Enter customer\'s full name', required: true),
                const SizedBox(height: 12),
                _buildTextField(phoneController, 'Phone Number', Icons.phone,
                    keyboardType: TextInputType.phone,
                    maxLength: 10,
                    inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                    validator: (v) {
                      if (v == null || v.trim().isEmpty) return 'Phone number is required';
                      if (v.length != 10) return 'Must be exactly 10 digits';
                      return null;
                    },
                    hintText: 'e.g., 9876543210 (10 digits)'),
                const SizedBox(height: 12),
                _buildTextField(emailController, 'Email (optional)', Icons.email,
                    keyboardType: TextInputType.emailAddress,
                    inputFormatters: [FilteringTextInputFormatter.allow(RegExp(r'[a-zA-Z0-9@._\-]'))],
                    validator: (v) {
                      final t = v?.trim() ?? '';
                      if (t.isEmpty) return null;
                      final pattern = r'^[\w.\-]+@([\w\-]+\.)+[\w]{2,4}$';
                      return RegExp(pattern).hasMatch(t) ? null : 'Enter a valid email';
                    },
                    hintText: 'e.g., customer@example.com'),
                const SizedBox(height: 12),

                if (_selectedType == 'company') ...[
                 // Extra space for company section
                  isMobile
                      ? Column(
                          children: _buildCompanyFields(isMobile: true),
                        )
                      : Column( // Column to stack the Rows for wide layout
                          children: [
                            Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Expanded(child: Column(children: _buildCompanyFields(left: true))),
                                const SizedBox(width: 16),
                                Expanded(child: Column(children: _buildCompanyFields(left: false))),
                              ],
                            ),
                            const SizedBox(height: 0), // Space before VAT
                            _buildTextField(vatController, 'VAT / GSTIN (optional)', Icons.confirmation_number, hintText: 'Enter VAT/GSTIN number'),
                          ],
                        ),
                ],
              ],
            ),
          ),
        ),
      ),
      actionsPadding: const EdgeInsets.fromLTRB(28, 0, 28, 28), // Padding around action buttons
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          style: TextButton.styleFrom(
            foregroundColor: Colors.grey[700],
            textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16),
          ),
          child: const Text('Cancel', style: TextStyle(fontFamily: 'Arial')),
        ),
        const SizedBox(width: 12),
        ElevatedButton.icon(
          icon: const Icon(Icons.save),
          label: const Text('Save', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
          onPressed: _onSavePressed,
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color.fromARGB(255, 1, 139, 82),
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
        ),
      ],
    );
  }
}

import 'package:flutter/material.dart';
import 'package:rcspos/localdb/orders_sqlite_helper.dart';
import 'package:intl/intl.dart'; // Add this import
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:excel/excel.dart';
import 'package:file_saver/file_saver.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'dart:typed_data';      
import 'package:excel/excel.dart' as xls;
import 'package:excel/excel.dart' as excel_pkg;


class OrderListPage extends StatefulWidget {
  const OrderListPage({Key? key}) : super(key: key);

  @override
  State<OrderListPage> createState() => _OrderListPageState();
}

class _OrderListPageState extends State<OrderListPage> {
  List<Map<String, dynamic>> _orders = [];
  String _searchQuery = '';
  int currentPage = 0;
  int rowsPerPage = 10;

  // --- Sorting State Variables ---
  int? _sortColumnIndex;
  bool _sortAscending = true;
  // --- End Sorting State Variables ---

  DateTime? _startDate;
DateTime? _endDate;

List<Map<String, dynamic>> get _filteredOrders {
  return _orders.where((order) {
    final searchMatch =
        order['order_id'].toString().toLowerCase().contains(_searchQuery) ||
        order['customer_name'].toString().toLowerCase().contains(_searchQuery) ||
        order['customer_phone'].toString().toLowerCase().contains(_searchQuery);

    DateTime orderDate;
    try {
      orderDate = DateTime.parse(order['timestamp']);
    } catch (_) {
      return false; // Skip invalid dates
    }

    // Convert to just the date (ignore time)
    final orderDateOnly = DateTime(orderDate.year, orderDate.month, orderDate.day);

    final withinStart = _startDate == null ||
        orderDateOnly.isAtSameMomentAs(DateTime(_startDate!.year, _startDate!.month, _startDate!.day)) ||
        orderDateOnly.isAfter(DateTime(_startDate!.year, _startDate!.month, _startDate!.day));

    final withinEnd = _endDate == null ||
        orderDateOnly.isAtSameMomentAs(DateTime(_endDate!.year, _endDate!.month, _endDate!.day)) ||
        orderDateOnly.isBefore(DateTime(_endDate!.year, _endDate!.month, _endDate!.day).add(const Duration(days: 1)));

    return searchMatch && withinStart && withinEnd;
  }).toList()
    ..sort((a, b) {
      if (_sortColumnIndex == null) return 0;

      final aValue = _getCellValue(a, _sortColumnIndex!);
      final bValue = _getCellValue(b, _sortColumnIndex!);
      final comp = aValue.toString().compareTo(bValue.toString());

      return _sortAscending ? comp : -comp;
    });
}

Future<void> _pickStartDate() async {
  final picked = await  showDatePicker(
    context: context,
    initialDate: DateTime.now(),
    firstDate: DateTime(2000),
    lastDate: DateTime.now(),
  );
  if (picked != null) {
    setState(() {
      _startDate = picked;
      currentPage = 0;
      _fetchOrders(); // Reload with new filter
    });
  }
}

Future<void> _pickEndDate() async {
  final picked = await showDatePicker(
    context: context,
    initialDate: DateTime.now(),
    firstDate: DateTime(2000),
    lastDate: DateTime.now(),
  );
  if (picked != null) {
    setState(() {
      _endDate = picked;
      currentPage = 0;
      _fetchOrders(); // Reload with new filter
    });
  }
}


void _exportCSV() async {
  final rows = <List<dynamic>>[
    ["Order ID", "Customer", "Phone", "Amount", "Date"],
    ..._filteredOrders.map((order) => [
      order['order_id'],
      order['customer_name'],
      order['customer_phone'],
      order['total'],
      order['timestamp'],
    ]),
  ];


  final csvData = const ListToCsvConverter().convert(rows);
  final directory = await getApplicationDocumentsDirectory();
  final path = "${directory.path}/orders.csv";
  final file = File(path);
  await file.writeAsString(csvData);

  await FileSaver.instance.saveFile(
    name: "orders",
    bytes: await file.readAsBytes(),
    mimeType: MimeType.csv,
  );
}

void _exportExcel() async {
  var excel = Excel.createExcel();
  Sheet sheet = excel['Orders'];
  sheet.appendRow(["Order ID", "Customer", "Phone", "Amount", "Date"]);
  for (var order in _filteredOrders) {
    sheet.appendRow([
      order['order_id'],
      order['customer_name'],
      order['customer_phone'],
      order['total'],
      order['timestamp'],
    ]);
  }

  final bytes = excel.encode()!;
  final directory = await getApplicationDocumentsDirectory();
  final path = "${directory.path}/orders.xlsx";
  File(path).writeAsBytesSync(bytes);

  await FileSaver.instance.saveFile(
    name: "orders",
    bytes: Uint8List.fromList(bytes),
    mimeType: MimeType.microsoftExcel,
  );
}

  // Helper function to get cell value based on column index
dynamic _getCellValue(Map<String, dynamic> order, int columnIndex) {
  switch (columnIndex) {
    case 0:
      return order['order_id'];
    case 1:
      return order['customer_name'];
    case 2:
      return order['customer_phone'];
    case 3:
      return order['total'];
    case 4:
      return order['timestamp'];
    default:
      return '';
  }
}

  void _onSort(int columnIndex, bool ascending) {
    setState(() {
      _sortColumnIndex = columnIndex;
      _sortAscending = ascending;
      currentPage = 0; 
    });
  }

  List<Map<String, dynamic>> get _paginatedOrders {
    final start = currentPage * rowsPerPage;
    final end = (start + rowsPerPage).clamp(0, _filteredOrders.length);
    return _filteredOrders.sublist(start, end);
  }

@override
void initState() {
  super.initState();
  _fetchOrders();
}


Future<void> _fetchOrders() async {
  final orders = await OrderSQLiteHelper().getAllOrders();
  setState(() {
    _orders = orders;
  });
}

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey[100],
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(106),
        child: AppBar(
          backgroundColor: const Color.fromARGB(255, 1, 139, 82),
          elevation: 0,
          automaticallyImplyLeading: false,
          flexibleSpace: SafeArea(
            child: Padding(
              padding: const EdgeInsets.all(5),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.arrow_back, color: Colors.white),
                        onPressed: () => Navigator.pop(context),
                      ),
                      const Text(
                        'Orders Details',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontFamily: 'Arial',
                          fontWeight: FontWeight.bold,
                        ),
                      ),
PopupMenuButton<String>(
 onSelected: (value) {
  setState(() {
    if (value == 'All') {
      _startDate = null;
      _endDate = null;
    } else if (value == 'Today') {
      final now = DateTime.now();
      _startDate = DateTime(now.year, now.month, now.day);
      _endDate = _startDate;
    }
    currentPage = 0; // Reset pagination
    _fetchOrders(); // <== ADD THIS LINE TO APPLY FILTER
  });
},

  itemBuilder: (context) => const [
    PopupMenuItem(value: 'All', child: Text('All')),
    PopupMenuItem(value: 'Today', child: Text('Today')),
  ],
  child: Row(
    children: const [
      Icon(Icons.filter_list, color: Colors.white, size: 18),
      SizedBox(width: 6),
      Text('Filter', style: TextStyle(color: Colors.white)),
      Icon(Icons.arrow_drop_down, color: Colors.white),
    ],
  ),
),

                    ],
                  ),
                  const SizedBox(height: 8),
                  Container(
                    height: 43,
                    margin: const EdgeInsets.symmetric(horizontal: 10),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: TextField(
                      onChanged: (value) {
                        setState(() => _searchQuery = value.toLowerCase());
                      },
                      decoration: const InputDecoration(
                        hintText: 'Search Orders...',
                        hintStyle: TextStyle(color: Colors.grey, fontFamily: 'Arial'),
                        border: InputBorder.none,
                        prefixIcon: Icon(Icons.search, color: Colors.grey),
                        contentPadding: EdgeInsets.symmetric(horizontal: 0, vertical: 10),
                      ),
                      style: const TextStyle(fontSize: 14),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      
      body: _orders.isEmpty
          ? const Center(child: Text('No orders found.'))
          : Column(
            
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Padding(
  padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 8),
  child: Row(
    children: [
Padding(
  padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 8),
  child: LayoutBuilder(
    builder: (context, constraints) {
      return Wrap(
        spacing: 12,
        runSpacing: 8,
        crossAxisAlignment: WrapCrossAlignment.center,
        children: [
          ElevatedButton.icon(
            icon: const Icon(Icons.date_range),
            label: Text(
              _startDate != null
                  ? DateFormat('dd/MM/yyyy').format(_startDate!)
                  : "Start Date",
            ),
            onPressed: _pickStartDate,
          ),
          ElevatedButton.icon(
            icon: const Icon(Icons.date_range),
            label: Text(
              _endDate != null
                  ? DateFormat('dd/MM/yyyy').format(_endDate!)
                  : "End Date",
            ),
            onPressed: _pickEndDate,
          ),
          if (_startDate != null || _endDate != null)
            TextButton(
              onPressed: () {
                setState(() {
                  _startDate = null;
                  _endDate = null;
                });
              },
              child: const Text('Clear Dates'),
            ),
          ElevatedButton.icon(
            icon: const Icon(Icons.file_download),
            label: const Text("Export CSV"),
            onPressed: _exportCSV,
          ),
          ElevatedButton.icon(
            icon: const Icon(Icons.file_download),
            label: const Text("Export Excel"),
            onPressed: _exportExcel,
          ),
        ],
      );
    },
  ),
),
  ],
                ),
                ),

                Expanded(
                  child: SingleChildScrollView(
                    scrollDirection: Axis.vertical,
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: ConstrainedBox(
                        constraints: BoxConstraints(minWidth: MediaQuery.of(context).size.width),
                        child: DataTable(
                          headingRowColor: MaterialStateColor.resolveWith(
                            (states) => const Color.fromARGB(255, 8, 72, 150),
                          ),
                          columnSpacing: 30,
                          // --- DataTable Sorting Properties ---
                          sortColumnIndex: _sortColumnIndex,
                          sortAscending: _sortAscending,
                          // --- End DataTable Sorting Properties ---
                          columns: [
                            DataColumn(
                              label: const Text('S.No', style: _headerStyle),
                            
                            ),
                            DataColumn(
                              label: const Text('Order ID', style: _headerStyle),
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),
 // Pass the onSort handler
                            ),
                            DataColumn(
                              label: const Text('Total', style: _headerStyle),
                              numeric: true, // Mark numeric columns
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('GST', style: _headerStyle),
                              numeric: true, // Mark numeric columns
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Customer', style: _headerStyle),
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Phone', style: _headerStyle),
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Mode', style: _headerStyle),
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Cash', style: _headerStyle),
                              numeric: true,
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Bank', style: _headerStyle),
                              numeric: true,
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Card', style: _headerStyle),
                              numeric: true,
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),
                            DataColumn(
                              label: const Text('Timestamp', style: _headerStyle),
                            onSort: (columnIndex, ascending) => _onSort(columnIndex, ascending),

                            ),


                          ],
                                                 rows: _paginatedOrders.asMap().entries.map((entry) {
                            final int rowIndex = entry.key; // Index within _paginatedOrders
                            final Map<String, dynamic> order = entry.value;

                            // Calculate the S.No.
                            final int serialNumber = (currentPage * rowsPerPage) + rowIndex + 1;

 String formattedTimestamp = '';
                            if (order['timestamp'] is String && order['timestamp'].isNotEmpty) {
                              try {
                                final DateTime dateTime = DateTime.parse(order['timestamp']);
                                // Format for date (dd/MM/yyyy)
                                final String datePart = DateFormat('dd/MM/yyyy').format(dateTime);
                                // Format for time (hh:mm a) - 'a' for AM/PM
                                final String timePart = DateFormat('hh:mm a').format(dateTime);
                                formattedTimestamp = '$datePart $timePart';
                              } catch (e) {
                                // Handle parsing errors, e.g., if timestamp format is unexpected
                                formattedTimestamp = 'Invalid Date';
                                print('Error parsing timestamp: ${order['timestamp']} - $e');
                              }
                            }

          return DataRow(
                              cells: [
                             DataCell(Text(serialNumber.toString())),
                                DataCell(Text(order['order_id'].toString())),
                                DataCell(Text('â‚¹${order['total'].toStringAsFixed(2)}')),
                                DataCell(Text('â‚¹${order['gst'].toStringAsFixed(2)}')),
                                DataCell(Text(order['customer_name'] ?? '')),
                                DataCell(Text(order['customer_phone'] ?? '')),
                                DataCell(Text(order['payment_mode'] ?? '')),
                                DataCell(Text('â‚¹${order['paid_cash'].toStringAsFixed(2)}')),
                                DataCell(Text('â‚¹${order['paid_bank'].toStringAsFixed(2)}')),
                                DataCell(Text('â‚¹${order['paid_card'].toStringAsFixed(2)}')),
                                DataCell(Text(formattedTimestamp)),
                              ],
                            );
                          }).toList(),
                        ),
                      ),
                    ),
                  ),
                ),
                _buildFooter(
                  _filteredOrders.length,
                  currentPage * rowsPerPage,
                  (currentPage * rowsPerPage + _paginatedOrders.length).clamp(0, _filteredOrders.length),
                  (_filteredOrders.length / rowsPerPage).ceil(),
                ),
              ],
            ),
    );
  }


Widget _buildFooter(int total, int start, int end, int totalPages) {
  return Container(
    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
    decoration: BoxDecoration(
      color: Colors.grey.shade100,
      borderRadius: const BorderRadius.vertical(bottom: Radius.circular(8)),

    ),
    child: Row(
      children: [
        Row(
          children: [
            const Text("Rows per page:",
                style: TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87)),
            const SizedBox(width: 8),
            DropdownButton<int>(
              value: rowsPerPage,
              items: [5, 10, 20, 50].map((e) {
                return DropdownMenuItem(
                  value: e,
                  child: Text(e.toString(), style: const TextStyle(fontFamily: 'Arial')),
                );
              }).toList(),
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    rowsPerPage = value;
                    currentPage = 0;
                  });
                }
              },
              style: const TextStyle(fontFamily: 'Arial', color: Colors.black87),
              icon: const Icon(Icons.arrow_drop_down, color: Color.fromARGB(255, 1, 129, 91)),
              underline: const SizedBox.shrink(),
            ),
          ],
        ),
        const Spacer(),
        Text(
          "${start + 1}â€“$end of $total",
          style: const TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87),
        ),
        IconButton(
          icon: const Icon(Icons.chevron_left),
          onPressed: currentPage > 0
              ? () => setState(() {
                    currentPage--;
                  })
              : null,
          color: const Color.fromARGB(255, 1, 129, 91),
          disabledColor: Colors.grey[400],
        ),
        IconButton(
          icon: const Icon(Icons.chevron_right),
          onPressed: (currentPage + 1) < (_filteredOrders.length / rowsPerPage).ceil()
              ? () => setState(() {
                    currentPage++;
                  })
              : null,
          color: const Color.fromARGB(255, 1, 129, 91),
          disabledColor: Colors.grey[400],
        ),
      ],
    ),
  );
}

}


const TextStyle _headerStyle = TextStyle(
  fontFamily: "Arial",
  fontWeight: FontWeight.w500,
  fontSize: 16,
  color: Colors.white,
); 



import 'package:flutter/material.dart';
import 'package:rcspos/components/bottonnavbar.dart';
import 'package:rcspos/components/sidebar.dart';
import 'package:rcspos/data/sampleproduct.dart';
import 'package:rcspos/screens/cartpage.dart';
import 'package:rcspos/screens/customerpage.dart';
import 'package:rcspos/screens/orderspage.dart';
import 'package:rcspos/screens/productpage.dart';
import 'package:rcspos/screens/productstablepage.dart';

class HomePage extends StatefulWidget {
  final int? categoryId;
  final String? categoryName;
  final List<dynamic>? selectedCustomers; 

  const HomePage({
    super.key,
    this.categoryId,
    this.categoryName,
    this.selectedCustomers,
  });

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  final Set<int> addedProductIds = {};
  final List<Map<String, dynamic>> cart = [];
  Map<String, dynamic>? selectedCustomer;


  String _searchQuery = '';
  String _filterMode = 'in_stock'; // 'all', 'in_stock', 'out_of_stock'
  String _filterLabel = 'In Stock';
  int _selectedIndex = 0;
  // bool _showOnlyInStock = true; // This can be removed, as _filterMode dictates it now.

  void handleAddToCart(Map<String, dynamic> product) {
    final int productId = product['id'];
    final int newQty = product['quantity'] ?? 1;

    setState(() {
      if (product.containsKey('remove') && product['remove'] == true) {
        cart.removeWhere((item) => item['id'] == productId);
        addedProductIds.remove(productId);
      } else {
        final index = cart.indexWhere((item) => item['id'] == productId);
        if (index >= 0) {
          cart[index]['quantity'] = newQty;
        } else {
          cart.add(product);
          addedProductIds.add(productId);
        }
      }
    });
  }

  Future<void> selectCustomer() async {
  final result = await Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => CustomerPage()),
  );

  if (result != null && result is Map<String, dynamic>) {
    setState(() {
      selectedCustomer = result;
    });
  }
}
 
Future<void> _onItemTapped(int index) async {
  setState(() => _selectedIndex = index);

  if (index == 1) {
    // Navigate to OrdersPage
    await Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => const OrdersPage()),
    );
  } else if (index == 2) {
    final updatedCart = await Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => Productstablepage(
        onAddToCart: handleAddToCart,
        addedProductIds: addedProductIds,
        searchQuery: _searchQuery,
        showOnlyInStock: _filterMode == 'in_stock'
            ? true
            : _filterMode == 'out_of_stock'
                ? false
                : null,
      )),
    );

    if (updatedCart != null && updatedCart is List<Map<String, dynamic>>) {
      setState(() {
        cart.clear();
        cart.addAll(updatedCart);
        addedProductIds.clear();
        addedProductIds.addAll(updatedCart.map((item) => item['id'] as int));
      });
    }
  } else if (index == 3) {
    final updatedCart = await Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => CartPage(cart: cart)),
    );

    if (updatedCart != null && updatedCart is List<Map<String, dynamic>>) {
      setState(() {
        cart.clear();
        cart.addAll(updatedCart);
        addedProductIds.clear();
        addedProductIds.addAll(updatedCart.map((item) => item['id'] as int));
      });
    }
  }
}

  @override
  Widget build(BuildContext context) {
    final isDesktop = MediaQuery.of(context).size.width >= 900;
    final isMobile = MediaQuery.of(context).size.width < 600;

    bool? actualShowOnlyInStock;
    if (_filterMode == 'in_stock') {
      actualShowOnlyInStock = true;
    } else if (_filterMode == 'out_of_stock') {
      actualShowOnlyInStock = false;
    }
    // If _filterMode is 'all', actualShowOnlyInStock remains null.


    return Scaffold(
      key: _scaffoldKey,
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(106),
        child: AppBar(
          backgroundColor: const Color.fromARGB(255, 1, 139, 82),
          elevation: 0,
          automaticallyImplyLeading: false,
          flexibleSpace: SafeArea(
            child: Padding(
              padding: const EdgeInsets.all(5),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Top bar
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Menu
                      IconButton(
                        icon: const Icon(Icons.menu, color: Colors.white),
                        onPressed: () => _scaffoldKey.currentState?.openDrawer(),
                      ),

                      // Title
                      const Text(
                        'RCS POS',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 20,
                          fontFamily: 'Arial',
                          fontWeight: FontWeight.bold,
                        ),
                      ),

                      // Right-side icons
                      Row(
                        children: [
                          // Cart
                          GestureDetector(
                            onTap: () async {
                              if (isMobile) {
                                final updatedCart = await Navigator.push(
                                  context,
                                  MaterialPageRoute(
                                    builder: (_) => CartPage(cart: cart),
                                  ),
                                );

                                if (updatedCart != null &&
                                    updatedCart is List<Map<String, dynamic>>) {
                                  setState(() {
                                    cart.clear();
                                    cart.addAll(updatedCart);
                                    addedProductIds.clear();
                                    addedProductIds.addAll(updatedCart.map((item) => item['id'] as int));
                                  });
                                }
                              } else {
                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                    content: Text("Cart is visible in side panel on desktop"),
                                  ),
                                );
                              }
                            },
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                const Icon(Icons.shopping_cart, color: Colors.white, size: 26),
                                if (cart.isNotEmpty)
                                  Positioned(
                                    top: 4,
                                    right: 4,
                                    child: Container(
                                      padding: const EdgeInsets.all(2),
                                      decoration: const BoxDecoration(
                                        color: Colors.red,
                                        shape: BoxShape.circle,
                                      ),
                                      constraints: const BoxConstraints(
                                        minWidth: 14,
                                        minHeight: 14,
                                      ),
                                      child: Text(
                                        cart.length.toString(),
                                        style: const TextStyle(
                                          color: Colors.white,
                                          fontSize: 10,
                                          fontWeight: FontWeight.bold,
                                          fontFamily: 'Arial',
                                        ),
                                        textAlign: TextAlign.center,
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 12),

                          // Filter Popup
                          PopupMenuButton<String>(
                            onSelected: (value) {
                              setState(() {
                                _filterLabel = value;
                                // Update _filterMode correctly
                                if (value == 'All') {
                                  _filterMode = 'all';
                                } else if (value == 'In Stock') {
                                  _filterMode = 'in_stock';
                                } else if (value == 'Out of Stock') {
                                  _filterMode = 'out_of_stock';
                                }
                              });
                            },
                            itemBuilder: (context) => const [
                              PopupMenuItem(value: 'All', child: Text('All')),
                              PopupMenuItem(value: 'In Stock', child: Text('In Stock')),
                              PopupMenuItem(value: 'Out of Stock', child: Text('Out of Stock')),
                            ],
                            child: Row(
                              children: [
                                const Icon(Icons.filter_list, color: Colors.white, size: 18),
                                const SizedBox(width: 6),
                                Text(
                                  _filterLabel,
                                  style: const TextStyle(color: Colors.white, fontSize: 14, fontFamily: 'Arial'),
                                ),
                                const Icon(Icons.arrow_drop_down, color: Colors.white),
                              ],
                            ),
                          ),

                          const SizedBox(width: 6),
                        ],
                      ),
                    ],
                  ),

                  // Search Bar
                  Container(
                    height: 43,
                    decoration: BoxDecoration(
                      color: Colors.white,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: TextField(
                      onChanged: (value) {
                        setState(() => _searchQuery = value.toLowerCase());
                      },
                      decoration: const InputDecoration(
                        hintText: 'What would you like to buy?',
                        hintStyle: TextStyle(color: Colors.grey, fontFamily: 'Arial'),
                        border: InputBorder.none,
                        prefixIcon: Icon(Icons.search, color: Colors.grey),
                        contentPadding: EdgeInsets.symmetric(horizontal: 0, vertical: 10),
                      ),
                      style: const TextStyle(fontSize: 14),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      drawer: const AppDrawer(),
      body: Row(
        children: [
          Expanded(
            flex: 3,
            // Pass the derived actualShowOnlyInStock
            child: ProductPage(
              categoryId: widget.categoryId,
              onAddToCart: handleAddToCart,
              addedProductIds: addedProductIds,
              searchQuery: _searchQuery,
              showOnlyInStock: actualShowOnlyInStock, // Pass the nullable bool here
            ),
          ),
          if (isDesktop) const VerticalDivider(width: 1),
          if (isDesktop)
            Expanded(
              flex: 5,
              child: CartPage(
  cart: cart,
  customerName: selectedCustomer?['name'],
),

            ),
        ],
        
      ),
       bottomNavigationBar: CustomBottomNav(
        selectedIndex: _selectedIndex,
        onTap: (index) => _onItemTapped(index),

      ),
    );
  }
  
}


// file: payment_page.dart

import 'package:flutter/material.dart';
import 'package:rcspos/screens/paymentsuccesspage.dart';

// ------------------ PAYMENT PAGE --------------------

class PaymentPage extends StatefulWidget {
  final double totalAmount;
  final String? customerName;
  final String? customerPhone;

  const PaymentPage({
    Key? key,
    required this.totalAmount,
    this.customerName,
    this.customerPhone,
  }) : super(key: key);
  @override
  State<PaymentPage> createState() => _PaymentPageState();
}



class _PaymentPageState extends State<PaymentPage> {
  double cashAmount = 0.0;
  double bankAmount = 0.0;
  bool isCashChecked = false;
  bool isBankChecked = false;

  double get totalPaid => cashAmount + bankAmount;
  double get returnAmount => totalPaid - widget.totalAmount;

  void _onPaymentChanged(String method, double amount) {
    setState(() {
      if (method == 'Cash') {
        cashAmount = amount;
      } else if (method == 'Bank') {
        bankAmount = amount;
      }
    });
  }
    void _onCheckboxChanged(String method, bool checked) {
    setState(() {
      if (method == 'Cash') {
        isCashChecked = checked;
        if (!checked) cashAmount = 0.0;
      } else if (method == 'Bank') {
        isBankChecked = checked;
        if (!checked) bankAmount = 0.0;
      }
    });
  }

  void _handlePayment() {
  Navigator.of(context).push(
    MaterialPageRoute(
      builder: (context) => const PaymentSuccessPage(),
    ),
  );
}


bool get isPaymentReady =>
    (isCashChecked || isBankChecked) && totalPaid >= widget.totalAmount;

  @override
  Widget build(BuildContext context) {
    final String formattedTotal = widget.totalAmount.toStringAsFixed(2);

    return Scaffold(
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        backgroundColor: const Color.fromARGB(255, 1, 139, 82)
,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('Payment', style: TextStyle(color: Colors.white)),
        actions: [
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white),
            onPressed: () => Navigator.of(context).popUntil((route) => route.isFirst),
          ),
          const SizedBox(width: 10),
        ],
      ),
 body: Column(
  children: [
    // Scrollable content
    Expanded(
      child: SingleChildScrollView(
        padding: const EdgeInsets.only(bottom: 16), // Prevent keyboard overlap
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Payment Summary Section
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const Text('Payment Summary',
                          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                      TextButton(
                        onPressed: () {
                          _onCheckboxChanged('Cash', false);
                          _onCheckboxChanged('Bank', false);
                          _onPaymentChanged('Cash', 0.0);
                          _onPaymentChanged('Bank', 0.0);
                        },
                        child: const Text('Clear All',
                            style: TextStyle(color: Color(0xFF4CAF50), fontSize: 16)),
                      ),
                    ],
                  ),
                  const SizedBox(height: 10),
                ],
              ),
            ),
            const Divider(),
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                children: [
                  PaymentOptionTile(
                    title: 'Cash',
                    totalAmount: widget.totalAmount,
                    onAmountChanged: (amount) => _onPaymentChanged('Cash', amount),
                    onCheckboxChanged: (checked) => _onCheckboxChanged('Cash', checked),
                  ),
                  PaymentOptionTile(
                    title: 'Bank',
                    totalAmount: widget.totalAmount,
                    onAmountChanged: (amount) => _onPaymentChanged('Bank', amount),
                    onCheckboxChanged: (checked) => _onCheckboxChanged('Bank', checked),
                  ),
                ],
              ),
            ),

            // Customer Section
          // Customer Section
Padding(
  padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
  child: Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            widget.customerName ?? 'No Customer Selected',
            style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          Text(
            widget.customerPhone ?? '',
            style: const TextStyle(color: Colors.grey, fontSize: 14),
          ),
        ],
      ),
      TextButton(
        onPressed: () => print('Change Customer'),
        child: const Text(
          'Change',
          style: TextStyle(color: Color(0xFF4CAF50), fontSize: 16),
        ),
      ),
    ],
  ),
),

            const Divider(),

            // Payment Details Section
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                children: [
                  _buildPaymentDetailRow('Total amount to be paid',
                      '\â‚¹${widget.totalAmount.toStringAsFixed(2)}'),
                  _buildPaymentDetailRow('Amount paid by Customer',
                      '\â‚¹${totalPaid.toStringAsFixed(2)}'),
                _buildPaymentDetailRow(
  returnAmount < 0 ? 'Remaining Amount' : 'Return Amount',
  '\â‚¹${returnAmount.abs().toStringAsFixed(2)}'),
       ],
              ),
            ),
          ],
        ),
      ),
    ),

    // Bottom Bar (fixed)
    Container(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 12.0),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        border: Border(top: BorderSide(color: Colors.grey[300]!, width: 1.0)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('Amt. to be paid',
                  style: TextStyle(fontSize: 14, color: Colors.grey)),
              Text('\â‚¹${widget.totalAmount.toStringAsFixed(2)}',
                  style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            ],
          ),
          ElevatedButton(
            onPressed: isPaymentReady ? _handlePayment : null,
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF00B0FF),
              padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
            ),
            child: const Text('Make Payment',
                style: TextStyle(fontSize: 18, color: Colors.white)),
          ),
        ],
      ),
    ),
  ],
),
    );
  }

  Widget _buildPaymentDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontSize: 16)),
          Text(value, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }
}

// ------------------ PAYMENT OPTION TILE --------------------
class PaymentOptionTile extends StatefulWidget {
  final String title;
  final double totalAmount;
  final Function(double) onAmountChanged;
  final Function(bool) onCheckboxChanged;

  const PaymentOptionTile({
    super.key,
    required this.title,
    required this.totalAmount,
    required this.onAmountChanged,
    required this.onCheckboxChanged,
  });

  @override
  State<PaymentOptionTile> createState() => _PaymentOptionTileState();
}

class _PaymentOptionTileState extends State<PaymentOptionTile> {
  bool isChecked = false;
  bool isExpanded = false;
  final TextEditingController _amountController = TextEditingController();
  double change = 0.0;

void _toggleCheckbox(bool? value) {
  setState(() {
    isChecked = value ?? false;
    isExpanded = isChecked;
    if (!isChecked) {
      _amountController.clear();
      widget.onAmountChanged(0.0);
    }
  });
  widget.onCheckboxChanged(isChecked);
}

void _onAmountChanged(String value) {
  double entered = double.tryParse(value) ?? 0.0;
  setState(() {
    change = entered - widget.totalAmount;
  });
  widget.onAmountChanged(entered);
}

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Header row
        Row(
          children: [
            Checkbox(
              value: isChecked,
              onChanged: _toggleCheckbox,
              activeColor: const Color(0xB3228CF0)
,
            ),
            Expanded(
              child: Text(widget.title, style: const TextStyle(fontSize: 16)),
            ),
            Text(
              '\â‚¹${widget.totalAmount.toStringAsFixed(2)}',
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            IconButton(
              icon: Icon(
                isExpanded ? Icons.keyboard_arrow_up : Icons.keyboard_arrow_down,
                color: Colors.teal,
              ),
              onPressed: isChecked
                  ? () => setState(() => isExpanded = !isExpanded)
                  : null,
            ),
          ],
        ),

        if (isExpanded)
          Padding(
            padding: const EdgeInsets.only(left: 32, right: 16, bottom: 8),
            child: Column(
              children: [
                TextField(
                  controller: _amountController,
                  keyboardType: TextInputType.number,
                  decoration: const InputDecoration(
                    labelText: 'Amount',
                    border: OutlineInputBorder(),
                  ),
                  onChanged: _onAmountChanged,
                ),
                const SizedBox(height: 6),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const SizedBox(),
                    Column(
                      crossAxisAlignment: CrossAxisAlignment.end,
                      children: [
                        const Text("Change"),
                        Text(
                          change.toStringAsFixed(2),
                          style: TextStyle(
                            color: change < 0 ? Colors.red : Colors.green,
                            fontWeight: FontWeight.bold,
                          ),
                        )
                      ],
                    ),
                  ],
                ),
              ],
            ),
          ),
      ],
    );
  }
} 







// file: payment_page.dart

import 'package:flutter/material.dart';
import 'dart:convert';
import 'dart:io'; // For HttpHeaders
import 'package:http/http.dart' as http;
import 'package:hive/hive.dart';
import 'package:rcspos/screens/paymentsuccesspage.dart';
import 'package:rcspos/utils/urls.dart'; // Make sure baseurl is correctly defined here

// Define your consistent color palette
const Color primaryGreen = Color.fromARGB(255, 1, 139, 82);
const Color lightGrey = Color(0xFFF0F2F5); // Softer background grey
const Color mediumGrey = Color(0xFFDCDCDC); // For borders/dividers
const Color darkText = Color(0xFF2C3E50); // Darker, professional text
const Color successColor = primaryGreen; // Using primary green for success indicators
const Color errorColor = Color(0xFFE74C3C); // Stronger red for error/remaining

// ------------------ PAYMENT PAGE --------------------

class PaymentPage extends StatefulWidget {
  final double totalAmount;
  final String? customerName;
  final String? customerPhone;

  const PaymentPage({
    Key? key,
    required this.totalAmount,
    this.customerName,
    this.customerPhone,
  }) : super(key: key);

  @override
  State<PaymentPage> createState() => _PaymentPageState();
}

class _PaymentPageState extends State<PaymentPage> {
  // Use a proper model for payment methods, if not already existing, create one
  // For now, we'll refine the existing Map<String, dynamic> approach for clarity
  List<Map<String, dynamic>> _paymentMethods = [];
  final Map<int, double> _paymentAmounts = {};
  final Map<int, bool> _paymentCheckedStates = {};

  bool _isLoading = true;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _fetchPaymentMethods();
  }

  // --- API CALL AND DATA HANDLING ---
  Future<void> _fetchPaymentMethods() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final box = await Hive.openBox('login');
      final rawSession = box.get('session_id');

      if (rawSession == null) {
        _errorMessage = 'Session not found. Please log in again.';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(_errorMessage!)),
        );
        return;
      }

      // Ensure session ID is correctly formatted
      final sessionId =
          rawSession.contains('session_id=') ? rawSession : 'session_id=$rawSession';
      final url = Uri.parse('$baseurl/api/pos.payment.method?query={id,name}');

      final response = await http.get(url, headers: {
        HttpHeaders.cookieHeader: sessionId,
        HttpHeaders.contentTypeHeader: 'application/json',
      });

      if (response.statusCode == 200) {
        final result = json.decode(response.body)['result'];
        setState(() {
          _paymentMethods = List<Map<String, dynamic>>.from(result);
          // Initialize checked states and amounts for fetched methods
          for (var method in _paymentMethods) {
            final methodId = method['id'] as int;
            _paymentCheckedStates[methodId] = false;
            _paymentAmounts[methodId] = 0.0;
          }
        });
      } else {
        _errorMessage =
            'Failed to load payment methods: ${response.statusCode} - ${response.body}';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(_errorMessage!)),
        );
      }
    } on SocketException {
      _errorMessage =
          'Network unavailable. Please check your internet connection.';
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(_errorMessage!)),
      );
    } catch (e) {
      _errorMessage = 'An unexpected error occurred: $e';
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(_errorMessage!)),
      );
      debugPrint('Error fetching payment methods: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  // --- CALCULATIONS ---
  double get totalPaid {
    double sum = 0.0;
    _paymentAmounts.forEach((id, amount) {
      if (_paymentCheckedStates[id] == true) {
        sum += amount;
      }
    });
    return sum;
  }

  double get returnAmount => totalPaid - widget.totalAmount;

  // --- STATE MANAGEMENT FOR PAYMENT OPTIONS ---
  void _onPaymentAmountChanged(int methodId, double amount) {
    setState(() {
      _paymentAmounts[methodId] = amount;
    });
  }

  void _onCheckboxChanged(int methodId, bool checked) {
    setState(() {
      _paymentCheckedStates[methodId] = checked;
      // When checking, pre-fill with total amount if amount is currently zero
      if (checked) {
        final currentAmount = _paymentAmounts[methodId] ?? 0.0;
        if (currentAmount == 0.0) {
          _paymentAmounts[methodId] = widget.totalAmount;
        }
      } else {
        _paymentAmounts[methodId] = 0.0;
      }
    });
  }

  void _clearAllPayments() {
    setState(() {
      _paymentAmounts.updateAll((key, value) => 0.0);
      _paymentCheckedStates.updateAll((key, value) => false);
    });
  }

  // --- PAYMENT PROCESSING ---
  bool get isPaymentReady =>
      _paymentCheckedStates.values.any((v) => v) &&
      totalPaid >= widget.totalAmount;

  void _handlePayment() {
    if (!isPaymentReady) return; // Should be handled by button disabled state

    // In a real application, send the selected payment methods and amounts to your backend
    debugPrint('Processing payment with amounts: $_paymentAmounts');

    // Example payload for the backend (adjust based on your API's needs)
    List<Map<String, dynamic>> paymentDetails = [];
    _paymentMethods.forEach((method) {
      final methodId = method['id'] as int;
      if (_paymentCheckedStates[methodId] == true) {
        paymentDetails.add({
          'payment_method_id': methodId,
          'amount': _paymentAmounts[methodId],
          'name': method['name'], // Include name for logging/debugging
        });
      }
    });
    debugPrint('Payment payload: $paymentDetails');

    Navigator.pushReplacement(
      context,
      MaterialPageRoute(builder: (_) => const PaymentSuccessPage()),
    );
  }

  // --- UI BUILD ---
  @override
  Widget build(BuildContext context) {
    final bool isWideScreen = MediaQuery.of(context).size.width > 700;

    return Scaffold(
      backgroundColor: Colors.white,
      resizeToAvoidBottomInset: true,
      appBar: AppBar(
        backgroundColor: primaryGreen,
        elevation: 0,
        leading: IconButton(
          icon: const Icon(Icons.arrow_back_ios_new_rounded, color: Colors.white),
          onPressed: () => Navigator.pop(context),
        ),
        title: const Text('Complete Payment',
            style: TextStyle(
                color: Colors.white, fontFamily: "Arial", fontWeight: FontWeight.bold)),
        actions: [
          IconButton(
            icon: const Icon(Icons.close_rounded, color: Colors.white),
            onPressed: () => Navigator.of(context).popUntil((route) => route.isFirst),
          ),
          const SizedBox(width: 10),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator(color: primaryGreen))
          : _errorMessage != null
              ? _buildErrorWidget()
              : _paymentMethods.isEmpty
                  ? _buildNoDataWidget()
                  : isWideScreen
                      ? _buildWideScreenLayout()
                      : _buildNarrowScreenLayout(),
    );
  }

  // --- Error and No Data Widgets ---
  Widget _buildErrorWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, color: errorColor, size: 60),
            const SizedBox(height: 20),
            Text(
              'Oops! Something went wrong.\n$_errorMessage',
              textAlign: TextAlign.center,
              style:
                  const TextStyle(fontSize: 18, color: darkText, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: _fetchPaymentMethods,
              icon: const Icon(Icons.refresh_rounded, size: 24),
              label: const Text('Try Again', style: TextStyle(fontSize: 18)),
              style: ElevatedButton.styleFrom(
                backgroundColor: primaryGreen,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                elevation: 5,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNoDataWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(10.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.info_outline, color: primaryGreen, size: 60),
            const SizedBox(height: 20),
            const Text(
              'No payment methods configured.\nPlease contact support or configure them in your Odoo backend.',
              textAlign: TextAlign.center,
              style:
                  TextStyle(fontSize: 18, color: darkText, fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 10),
            ElevatedButton.icon(
              onPressed: _fetchPaymentMethods,
              icon: const Icon(Icons.refresh_rounded, size: 24),
              label: const Text('Refresh Methods', style: TextStyle(fontSize: 18)),
              style: ElevatedButton.styleFrom(
                backgroundColor: primaryGreen,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                elevation: 5,
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- Layout for Narrow Screens (Mobile) ---
  Widget _buildNarrowScreenLayout() {
    return Column(
      children: [
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(0.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildPaymentSummaryCard(),
                const SizedBox(height: 25),
                _buildCustomerInfoCard(),
                const SizedBox(height: 25),
                _buildPaymentDetailsCard(),
              ],
            ),
          ),
        ),
        _buildBottomPaymentBar(),
      ],
    );
  }

  // --- Layout for Wide Screens (Tablet/Desktop) ---
Widget _buildWideScreenLayout() {
  return Row(
    crossAxisAlignment: CrossAxisAlignment.start, // Align top of both panels
    children: [
      Expanded(
        flex: 3,
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildPaymentSummaryCard(),
              const SizedBox(height: 20),
              _buildCustomerInfoCard(),
            ],
          ),
        ),
      ),
      const VerticalDivider(width: 1.5, thickness: 1.5, color: mediumGrey),
      Expanded(
        flex: 2,
        child: Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min, // Prevents it from expanding vertically
            children: [
              _buildPaymentDetailsCard(),
              const SizedBox(height: 20),
              Align(
                alignment: Alignment.center,
                child: ElevatedButton.icon(
                  onPressed: isPaymentReady ? _handlePayment : null,
                  icon: const Icon(Icons.check_circle_rounded, size: 24),
                  label: const Text('Complete Payment'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: primaryGreen,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 20),
                    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
                    textStyle: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                    elevation: 8,
                    shadowColor: primaryGreen.withOpacity(0.5),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    ],
  );
}

  // --- Reusable Widget Builders ---

Widget _buildPaymentSummaryCard() {
  return Padding(
    padding: const EdgeInsets.all(0.0),
    child: Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Payment Methods',
          style: TextStyle(
            fontSize: 17.5,
            fontWeight: FontWeight.w600,
            fontFamily: "Arial",
            color: darkText.withOpacity(0.9),
          ),
        ),
        const Divider(height: 5, thickness: 1.5, color: mediumGrey),

        _buildPaymentDetailRow(
          'Total Amount Payable',
          '\â‚¹${widget.totalAmount.toStringAsFixed(2)}',
          Colors.black,
          FontWeight.w500,
          
         
        ),
        const SizedBox(height: 15),

        // Dynamically generate PaymentOptionTiles
        ..._paymentMethods.map((method) {
          final methodId = method['id'] as int;
          return Padding(
            padding: const EdgeInsets.only(bottom: 10.0),
            child: PaymentOptionTile(
              key: ValueKey(methodId),
              title: method['name'] as String,
              icon: _getIconForPaymentMethod(method['name'] as String),
              onAmountChanged: (amount) => _onPaymentAmountChanged(methodId, amount),
              onCheckboxChanged: (checked) => _onCheckboxChanged(methodId, checked),
              isChecked: _paymentCheckedStates[methodId] ?? false,
              initialAmount: _paymentAmounts[methodId] ?? 0.0,
              transactionTotalAmount: widget.totalAmount,
            ),
          );
        }).toList(),

        const Divider(height: 10, thickness: 1.0, color: mediumGrey),
        Container(
          padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 15),
          decoration: BoxDecoration(
            color: returnAmount < 0
                ? errorColor.withOpacity(0.1)
                : successColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: returnAmount < 0
                  ? errorColor.withOpacity(0.4)
                  : successColor.withOpacity(0.4),
              width: 1,
            ),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                returnAmount < 0 ? 'Balance Due' : 'Change Due',
                style: TextStyle(
                  fontSize: 17,
                  fontFamily: "Arial",
                  color: darkText.withOpacity(0.9),
                  fontWeight: FontWeight.w600,
                ),
              ),
              Text(
                '\â‚¹${returnAmount.abs().toStringAsFixed(2)}',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: returnAmount < 0 ? errorColor : successColor,
                ),
              ),
            ],
          ),
        ),
      ],
    ),
  );
}

  IconData _getIconForPaymentMethod(String name) {
    switch (name.toLowerCase()) {
      case 'cash':
        return Icons.money_rounded;
      case 'bank':
        return Icons.credit_card_rounded;
      case 'customer account':
        return Icons.person_rounded;
      case 'upi':
        return Icons.qr_code_rounded;
      default:
        return Icons.payment_rounded;
    }
  }

  Widget _buildCustomerInfoCard() {
    return Padding(
      padding: const EdgeInsets.all(0.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
         
Container(
  padding: const EdgeInsets.all(16),
  decoration: BoxDecoration(
    color: Colors.white,
    borderRadius: BorderRadius.circular(12),
    border: Border.all(color: mediumGrey.withOpacity(0.6), width: 1),
    boxShadow: [
      BoxShadow(
        color: Colors.black.withOpacity(0.03),
        blurRadius: 5,
        offset: const Offset(0, 2),
      ),
    ],
  ),
  child: Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: [
      const Text(
        'Customer Details',
        style: TextStyle(
          fontSize: 17,
          fontWeight: FontWeight.bold,
          fontFamily: "Arial",
          color: darkText,
        ),
      ),
      const Divider(height: 20, thickness: 1.2, color: mediumGrey),
      Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  widget.customerName ?? 'No Customer Selected',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                    fontFamily: "Arial",
                    color: widget.customerName != null ? darkText : Colors.grey[600],
                  ),
                ),
                const SizedBox(height: 4),
                if (widget.customerPhone != null && widget.customerPhone!.isNotEmpty)
                  Text(
                    widget.customerPhone!,
                    style: const TextStyle(
                      color: Color.fromARGB(255, 90, 90, 90),
                      fontSize: 15.5,
                      fontFamily: "Arial",
                    ),
                  ),
              ],
            ),
          ),
          TextButton.icon(
            onPressed: () {
              debugPrint('Change Customer');
            },
            icon: const Icon(Icons.edit_rounded, color: primaryGreen, size: 20),
            label: const Text(
              'Change',
              style: TextStyle(
                color: primaryGreen,
                fontSize: 15.5,
                fontWeight: FontWeight.w600,
                fontFamily: "Arial",
              ),
            ),
            style: TextButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
              side: BorderSide(color: primaryGreen.withOpacity(0.8), width: 1.4),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
              backgroundColor: Colors.transparent,
            ),
          ),
        ],
      ),
    ],
  ),
),

        ],
      ),
    );
  }

  Widget _buildPaymentDetailsCard() {
    return Padding(
      padding: const EdgeInsets.all(0.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('Transaction Summary',
              style: TextStyle(
                  fontSize: 17.5,fontFamily: "Arial", fontWeight: FontWeight.bold, color: darkText.withOpacity(0.9))),
          const Divider(height: 5, thickness: 1.5, color: mediumGrey),
          _buildPaymentDetailRow('Total amount to be paid',
              '\â‚¹${widget.totalAmount.toStringAsFixed(2)}', darkText, FontWeight.bold),
          _buildPaymentDetailRow('Amount received from Customer',
              '\â‚¹${totalPaid.toStringAsFixed(2)}', darkText, FontWeight.bold),
        ],
      ),
    );
  }

  Widget _buildBottomPaymentBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 28.0, vertical: 20.0),
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.18),
            blurRadius: 20,
            offset: const Offset(0, -8),
          ),
        ],
      ),
      child: SafeArea(
        top: false,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('Net Amount', style: TextStyle(fontSize: 17, color: Colors.grey)),
                Text('\â‚¹${widget.totalAmount.toStringAsFixed(2)}',
                    style: const TextStyle(fontSize: 30, fontWeight: FontWeight.bold, color: darkText)),
              ],
            ),
            ElevatedButton.icon(
              onPressed: isPaymentReady ? _handlePayment : null,
              icon: const Icon(Icons.check_circle_rounded, size: 24),
              label: const Text('Complete Payment'),
              style: ElevatedButton.styleFrom(
                backgroundColor: primaryGreen,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 50, vertical: 25),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
                textStyle: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
                elevation: 8,
                shadowColor: primaryGreen.withOpacity(0.5),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPaymentDetailRow(
      String label, String value, Color color, FontWeight fontWeight) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 10.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontSize: 17,fontFamily: "Arial", color: darkText)),
          Text(value, style: TextStyle(fontSize: 17.5,fontFamily: "Arial", fontWeight: FontWeight.w600, color: color)),
        ],
      ),
    );
  }
}

// ------------------ PAYMENT OPTION TILE --------------------
class PaymentOptionTile extends StatefulWidget {
  final String title;
  final IconData icon;
  final Function(double) onAmountChanged;
  final Function(bool) onCheckboxChanged;
  final bool isChecked;
  final double initialAmount;
  final double transactionTotalAmount;

  const PaymentOptionTile({
    Key? key, // Added Key parameter
    required this.title,
    required this.icon,
    required this.onAmountChanged,
    required this.onCheckboxChanged,
    this.isChecked = false,
    this.initialAmount = 0.0,
    required this.transactionTotalAmount,
  }) : super(key: key); // Pass key to super

  @override
  State<PaymentOptionTile> createState() => _PaymentOptionTileState();
}

class _PaymentOptionTileState extends State<PaymentOptionTile> {
  late bool isChecked;
  late bool isExpanded;
  late TextEditingController _amountController; // Changed to late and initialized in initState

  @override
  void initState() {
    super.initState();
    isChecked = widget.isChecked;
    isExpanded = widget.isChecked;
    _amountController = TextEditingController(
      text: widget.initialAmount > 0 ? widget.initialAmount.toStringAsFixed(2) : '',
    );
  }

  @override
  void didUpdateWidget(covariant PaymentOptionTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.isChecked != oldWidget.isChecked) {
      setState(() {
        isChecked = widget.isChecked;
        isExpanded = isChecked;
        if (!isChecked) {
          _amountController.clear();
        } else {
          // Only pre-fill if the amount is currently 0 or not yet set for this method
          final currentParsedAmount = double.tryParse(_amountController.text) ?? 0.0;
          if (currentParsedAmount == 0.0) {
            _amountController.text = widget.transactionTotalAmount.toStringAsFixed(2);
          }
        }
      });
    }

    if (widget.initialAmount != oldWidget.initialAmount) {
      final double currentParsedAmount = double.tryParse(_amountController.text) ?? 0.0;
      if (widget.initialAmount != currentParsedAmount) {
        if (widget.initialAmount == 0.0) {
          _amountController.clear();
        } else {
          _amountController.text = widget.initialAmount.toStringAsFixed(2);
        }
      }
    }
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  void _toggleCheckbox(bool? value) {
    setState(() {
      isChecked = value ?? false;
      isExpanded = isChecked;
      if (!isChecked) {
        _amountController.clear();
        widget.onAmountChanged(0.0);
      } else {
        _amountController.text = widget.transactionTotalAmount.toStringAsFixed(2);
        widget.onAmountChanged(widget.transactionTotalAmount);
      }
    });
    widget.onCheckboxChanged(isChecked);
  }

  void _onAmountChangedInternal(String value) {
    double entered = double.tryParse(value) ?? 0.0;
    widget.onAmountChanged(entered);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        InkWell(
          onTap: () {
            _toggleCheckbox(!isChecked);
          },
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding: const EdgeInsets.symmetric(vertical: 5.0, horizontal: 15.0),
            decoration: BoxDecoration(
              color:  Colors.white,
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: isChecked ? primaryGreen.withOpacity(0.7) : mediumGrey.withOpacity(0.8),
                width: isChecked ? 1.2 : 1.5,
              ),
              boxShadow: isChecked
                  ? [
                      BoxShadow(
                        color: primaryGreen.withOpacity(0.2),
                        blurRadius: 8,
                        offset: const Offset(0, 4),
                      ),
                    ]
                  : [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.05),
                        blurRadius: 3,
                        offset: const Offset(0, 2),
                      ),
                    ],
            ),
            child: Row(
              children: [
                Checkbox(
                  value: isChecked,
                  onChanged: _toggleCheckbox,
                  activeColor: primaryGreen,
                  checkColor: Colors.white,
                  side: BorderSide(color: primaryGreen.withOpacity(0.8), width: 1.5),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                ),
                const SizedBox(width: 8),
                Icon(widget.icon,
                    color: isChecked ? primaryGreen : darkText.withOpacity(0.7), size: 22),
                const SizedBox(width: 4),
                Expanded(
                  child: Text(widget.title,
                      style: const TextStyle(
                          fontSize: 15.8,
                          fontFamily: "Arial",
                          fontWeight: FontWeight.w500,
                          color: Color.fromARGB(255, 36, 36, 36))),
                ),
                Text(
                  '\â‚¹${_amountController.text.isNotEmpty && isChecked ? (double.tryParse(_amountController.text) ?? 0.0).toStringAsFixed(2) : '0.00'}',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: darkText),
                ),
                Padding(
                  padding: const EdgeInsets.only(left: 12.0),
                  child: Icon(
                    isExpanded ? Icons.keyboard_arrow_up_rounded : Icons.keyboard_arrow_down_rounded,
                    color: isChecked ? primaryGreen : Colors.grey[700],
                    size: 20,
                  ),
                ),
              ],
            ),
          
          ),
        ),
        if (isExpanded)
          Padding(
            padding: const EdgeInsets.only(left: 45, right: 18, top: 15, bottom: 10),
            child: TextField(
              controller: _amountController,
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: 'Enter Amount',
                hintText: 'e.g., ${widget.transactionTotalAmount.toStringAsFixed(2)}',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(color: mediumGrey.withOpacity(0.8), width: 1.0),
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: const BorderSide(color: primaryGreen, width: 1.0),
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide(color: const Color.fromARGB(255, 27, 27, 27)!, width: 0.7),
                ),
                prefixText: '\â‚¹',
                contentPadding: const EdgeInsets.symmetric(vertical: 18, horizontal: 18),
                labelStyle: TextStyle(color: const Color.fromARGB(255, 1, 12, 24).withOpacity(0.7), fontSize: 17, fontFamily: "Arial"),
                hintStyle: TextStyle(color: const Color.fromARGB(255, 121, 120, 120), fontSize: 17),
              ),
              style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500, color: darkText),
              onChanged: _onAmountChangedInternal,
            ),
          ),
     
      ],
    );
  }
}



import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/localdb/customersqlitehelper.dart';
import 'package:rcspos/screens/CreditCustomersPage.dart';

import 'package:rcspos/screens/createcustomer.dart';

import 'package:rcspos/screens/editcustomer.dart'; // Ensure this exists and expects a 'Customer' object
import 'package:rcspos/screens/home.dart';
import 'package:rcspos/utils/urls.dart';
import 'package:flutter/services.dart';
import 'dart:async';

const TextStyle _headerStyle = TextStyle(
  fontFamily: "Arial",
  fontWeight: FontWeight.w500,
  fontSize: 16,
  color: Colors.white,
);

class Customer {
  final int id;
  final String name;
  final String? email;
  final String? phone;
  final String contactAddress;
  final Map<String, dynamic> posConfig;
  final String companyType;

  Customer({
    required this.id,
    required this.name,
    required this.posConfig,
    this.email,
    this.phone,
    required this.contactAddress,
    required this.companyType,
  });

  factory Customer.fromMap(Map<String, dynamic> map) {
    return Customer(
      id: map['id'] as int,
      name: map['name'] ?? '',
      email: map['email'],
      phone: map['phone'],
      contactAddress: map['contact_address'] ?? '',
      companyType: map['company_type'] ?? 'person',
      posConfig: map['posConfig'] is Map<String, dynamic>
          ? map['posConfig'] as Map<String, dynamic>
          : <String, dynamic>{},
    );
  }
}

class CustomerPage extends StatefulWidget {
  const CustomerPage({Key? key}) : super(key: key);

  @override
  State<CustomerPage> createState() => _CustomerPageState();
}

class _CustomerPageState extends State<CustomerPage> {
  late final Customersqlitehelper customerDbHelper;
  List<Customer> customers = [];
   int? _selectedCustomerId; 
  final Set<int> _selectedCustomerIds = {}; 

 final ScrollController _verticalTableScrollController = ScrollController();
  int rowsPerPage = 10;
  int currentPage = 0;
  int? _sortColumnIndex;
  bool _sortAscending = true;
  String _searchQuery = '';
  String _companyFilter = 'all';

  bool isLoading = false;
  Timer? _syncTimer;

  @override
@override
void initState() {
  super.initState();

  _fetchCustomersFromApiOnly();
_syncTimer = Timer.periodic(const Duration(minutes: 30), (_) {
    _fetchCustomersFromApiOnly();
  });
}
Future<void> _fetchCustomersFromApiOnly() async {
  setState(() => isLoading = true);

  final box = await Hive.openBox('session');
  final rawSession = box.get('session_id');
String sessionId = '';
if (rawSession != null && rawSession.isNotEmpty) {
  sessionId = rawSession.toString().startsWith('session_id=')
      ? rawSession.toString()
      : 'session_id=$rawSession';
}


  final apiUrl =
      '$baseurl/api/res.partner?query={id,name,email,phone,contact_address,company_type}&filter=[["customer_rank",">=",0]]';

  try {
    final response = await http.get(
      Uri.parse(apiUrl),
      headers: {
        HttpHeaders.cookieHeader: sessionId,
        HttpHeaders.contentTypeHeader: 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final Map<String, dynamic> jsonResponse = json.decode(response.body);

      // Adjust this according to your API response structure:
      // For example, if your API returns { "result": [ ... ] }
      final List<dynamic> data = jsonResponse['result'] ?? [];

      setState(() {
        customers = data.map((item) => Customer.fromMap(item)).toList();
      });
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to fetch customers: ${response.statusCode}')),
      );
    }
  } catch (e) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Error fetching customers: $e')),
    );
  } finally {
    setState(() => isLoading = false);
  }
}

 
  


 
  @override
  void dispose() {
    _syncTimer?.cancel();
    super.dispose();
  }

// Add in your Customersqlitehelper class


  void _onSort(int columnIndex, bool ascending) {
    setState(() {
      _sortColumnIndex = columnIndex;
      _sortAscending = ascending;
      currentPage = 0; 
      _selectedCustomerIds.clear(); 
      _selectedCustomerId = null;
    });
  }

  void _downloadAsPDF() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Downloading as PDF...', style: TextStyle(fontFamily: 'Arial'))),
    );
    debugPrint("Download as PDF tapped");
  
  }

  void _downloadAsExcel() {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Downloading as Excel...', style: TextStyle(fontFamily: 'Arial'))),
    );
    debugPrint("Download as Excel tapped");

  }

  void _showDownloadOptions() {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Download as', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.picture_as_pdf, color: Color.fromARGB(255, 1, 129, 91)),
                title: const Text('PDF', style: TextStyle(fontFamily: 'Arial')),
                onTap: () {
                  Navigator.pop(context); // close dialog
                  _downloadAsPDF(); // call your PDF logic
                },
              ),
              ListTile(
                leading: const Icon(Icons.grid_on, color: Color.fromARGB(255, 1, 129, 91)),
                title: const Text('Excel', style: TextStyle(fontFamily: 'Arial')),
                onTap: () {
                  Navigator.pop(context);
                  _downloadAsExcel(); // call your Excel logic
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _confirmDeleteCustomer(Customer customer) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Confirm Deletion', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
        content: Text('Are you sure you want to delete ${customer.name}?', style: const TextStyle(fontFamily: 'Arial')),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            style: TextButton.styleFrom(
              foregroundColor: Colors.grey[700],
              textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16),
            ),
            child: const Text('Cancel', style: TextStyle(fontFamily: 'Arial')),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx); // Close dialog
              await _deleteCustomer(customer.id); // Call delete API
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
              textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16, fontWeight: FontWeight.bold),
            ),
            child: const Text('Delete', style: TextStyle(fontFamily: 'Arial')),
          ),
        ],
      ),
    );
  }

  Future<void> _deleteCustomer(int customerId) async {
    final box = await Hive.openBox('login');
    final rawSession = box.get('session_id');
    if (rawSession == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Session not found.', style: TextStyle(fontFamily: 'Arial'))),
      );
      return;
    }
    final sessionId = rawSession.contains('session_id=') ? rawSession : 'session_id=$rawSession';

    final url = Uri.parse('$baseurl/mobile/delete_customer/$customerId');
    try {
      final response = await http.delete(
        url,
        headers: {
          HttpHeaders.cookieHeader: sessionId,
          HttpHeaders.contentTypeHeader: 'application/json',
        },
      );

      if (response.statusCode == 200) {
      
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Customer deleted successfully!', style: TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.green),
        );
        // fetchCustomers(); 
      } else {
        final error = json.decode(response.body)['error']['message'] ?? 'Unknown error';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Failed to delete customer: $error', style: const TextStyle(fontFamily: 'Arial')), backgroundColor: Colors.red),
        );
        debugPrint('Error response: ${response.body}');
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('An error occurred: $e', style: const TextStyle(fontFamily: 'Arial'))),
      );
      debugPrint('Exception during customer deletion: $e');
    }
  }

  void _startPaymentProcessForSelectedCustomers() {
    if (_selectedCustomerIds.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select at least one customer to process payment.', style: TextStyle(fontFamily: 'Arial'))),
      );
      return;
    }

    final List<Customer> customersToProcess = customers
        .where((customer) => _selectedCustomerIds.contains(customer.id))
        .toList();

    debugPrint('Initiating payment process for customer IDs: ${_selectedCustomerIds.toList()}');

    if (customersToProcess.isNotEmpty) {
      // Assuming you want to return the first selected customer's data to the previous screen
      Navigator.pop(context, {
        'id': customersToProcess.first.id,
        'name': customersToProcess.first.name,
        'email': customersToProcess.first.email,
        'phone': customersToProcess.first.phone,
      });
    } else {
       ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No selected customer found.', style: TextStyle(fontFamily: 'Arial'))),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
        final double screenWidth = MediaQuery.of(context).size.width;
    final bool isMobile = screenWidth < 600; 
    // 1. Filtering Logic
    final filteredCustomers = customers.where((c) {
      final lowerCaseSearchQuery = _searchQuery.toLowerCase();
      final matchesSearch = c.name.toLowerCase().contains(lowerCaseSearchQuery) ||
          (c.email ?? '').toLowerCase().contains(lowerCaseSearchQuery) ||
          (c.phone ?? '').toLowerCase().contains(lowerCaseSearchQuery) ||
          c.contactAddress.toLowerCase().contains(lowerCaseSearchQuery) ||
          c.companyType.toLowerCase().contains(lowerCaseSearchQuery);

      final matchesType = _companyFilter == 'all' || c.companyType == _companyFilter;

      return matchesSearch && matchesType;
    }).toList(); // <--- Important: .toList() creates a new mutable list

    // 2. Sorting Logic (APPLY HERE, AFTER FILTERING)
    if (_sortColumnIndex != null) {
      filteredCustomers.sort((a, b) { // Sort the filtered list
        Comparable aValue, bValue;
        switch (_sortColumnIndex) {
          case 0: // S.No column (not sortable, this case is likely for the actual DataColumn index, not internal data index)
            return 0; // Or better, adjust _onSort's columnIndex to skip this
          case 1: // Name (Adjusted index based on DataColumn setup: S.No is 0, Name is 1 if checkbox is removed)
            aValue = a.name.toLowerCase();
            bValue = b.name.toLowerCase();
            break;
          case 2: // Email (Adjusted index)
            aValue = (a.email ?? '').toLowerCase();
            bValue = (b.email ?? '').toLowerCase();
            break;
          case 3: // Phone (Adjusted index)
            aValue = (a.phone ?? '').toLowerCase();
            bValue = (b.phone ?? '').toLowerCase();
            break;
          case 4: // Address (Adjusted index)
            aValue = a.contactAddress.toLowerCase();
            bValue = b.contactAddress.toLowerCase();
            break;
          case 5: // Company Type (Adjusted index)
            aValue = a.companyType.toLowerCase();
            bValue = b.companyType.toLowerCase();
            break;
          default:
            return 0; // For Actions, no sorting
        }
        return _sortAscending ? Comparable.compare(aValue, bValue) : Comparable.compare(bValue, aValue);
      });
    }
    

    // 3. Pagination Logic (applied AFTER filtering and sorting)
    final totalFilteredCustomers = filteredCustomers.length;
    final totalPages = (totalFilteredCustomers / rowsPerPage).ceil();
    final startIndex = currentPage * rowsPerPage;
    final endIndex = (startIndex + rowsPerPage).clamp(0, totalFilteredCustomers);
    final visibleCustomers = filteredCustomers.sublist(startIndex, endIndex);


    final bool allVisibleCustomersSelected =
        visibleCustomers.isNotEmpty && visibleCustomers.every((customer) => _selectedCustomerIds.contains(customer.id));

    return Scaffold(
  appBar: PreferredSize(
        preferredSize: Size.fromHeight(isMobile ? 180 : 120),
        child: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          automaticallyImplyLeading: false,
          flexibleSpace: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                colors: [Color.fromARGB(255, 44, 145, 113), Color(0xFF185A9D)],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
            child: SafeArea(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        GestureDetector(
                         onTap: () {
  Navigator.pushReplacement( // <--- Replaces the CustomerPage route
    context,
    MaterialPageRoute(builder: (context) => HomePage(posConfig: {})),
  );
},
                          child: Row(
                            children: const [
                              Icon(Icons.arrow_back, color: Colors.white, size: 24),
                              SizedBox(width: 8),
                              Text(
                                'Customer Table',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontSize: 20,
                                  fontFamily: 'Arial',
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                        Flexible( 
                          child: Wrap( 
                            spacing: 10, 
                            runSpacing: 10, 
                            alignment: WrapAlignment.end, 
                            children: [
                              _buildCompanyFilterDropdown(),
                              _buildCreditCustomersButton(),
                            ],
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 10),
                    Container(
                      height: 40,
                      decoration: BoxDecoration(
                        color: Colors.white,
                        borderRadius: BorderRadius.circular(28),
                      ),
                      child: TextField(
                        onChanged: (value) {
                          setState(() {
                            _searchQuery = value;
                            currentPage = 0; // Reset pagination on search change
                            _selectedCustomerIds.clear(); // Clear selections on search change
                          });
                        },
                        decoration: const InputDecoration(
                          hintText: 'Search customers...',
                          hintStyle: TextStyle(color: Colors.grey, fontFamily: 'Arial'),
                          border: InputBorder.none,
                          prefixIcon: Icon(Icons.search, color: Colors.grey),
                          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        ),
                        style: const TextStyle(fontSize: 16, fontFamily: 'Arial', color: Colors.black87),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
           body: isLoading
          ? const Center(child: CircularProgressIndicator(color: Color.fromARGB(255, 1, 129, 91)))
          : Padding(
              padding: const EdgeInsets.symmetric(horizontal: 0.0), // Padding for the whole content
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 16),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Wrap(
                        spacing: 12,
                        runSpacing: 12,
                        children: [
ElevatedButton.icon(
 onPressed: () async {
  final result = await showDialog<bool>(
    context: context,
    barrierColor: Colors.black.withAlpha((0.5 * 255).toInt()),
    builder: (ctx) => const CreateCustomerPage(),
  );
  if (result == true) {
    await _fetchCustomersFromApiOnly(); // Reloads local DB data
  }


  },
  style: ElevatedButton.styleFrom(
    backgroundColor: const Color.fromARGB(255, 201, 202, 201),
    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 8),
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
  ),
  icon: const Icon(Icons.add, color: Colors.black),
  label: const Text(
    'ADD CUSTOMER',
    style: TextStyle(
      color: Colors.black,
      fontFamily: 'Arial',
      fontSize: 13,
      fontWeight: FontWeight.w600,
    ),
  ),
),
                          // Payment Process Button
                          if (_selectedCustomerIds.isNotEmpty)
                            ElevatedButton.icon(
                              onPressed: _startPaymentProcessForSelectedCustomers,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: const Color.fromARGB(255, 1, 129, 91),
                                padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                              ),
                              icon: const Icon(Icons.payment, color: Colors.white),
                              label: const Text(
                                'Done',
                                style: TextStyle(
                                  color: Colors.white,
                                  fontFamily: 'Arial',
                                  fontSize: 14,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ),

                          ElevatedButton.icon(
                            onPressed: _showDownloadOptions,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.blueGrey[700],
                              padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 10),
                              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
                            ),
                            icon: const Icon(Icons.download, color: Colors.white),
                            label: const Text(
                              'DOWNLOAD',
                              style: TextStyle(
                                color: Colors.white,
                                fontFamily: 'Arial',
                                fontSize: 13,
                              ),
                            ),
                          ),
                        ],
                      )
                    ],
                  ),
                  const SizedBox(height: 16),
                  if (visibleCustomers.isEmpty)
                    Expanded(
                      child: Center(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.person_off, size: 48, color: Colors.grey[400]),
                            const SizedBox(height: 8),
                            Text(
                              _searchQuery.isNotEmpty || _companyFilter != 'all'
                                  ? 'No customers match your criteria.'
                                  : 'No customers found.',
                              style: TextStyle(
                                fontSize: 16,
                                fontFamily: 'Arial',
                                color: Colors.grey[600],
                              ),
                            ),
                          ],
                        ),
                      ),
                    )
                  else
               Expanded(
  child: SingleChildScrollView(
    controller: _verticalTableScrollController, // vertical scroll
    scrollDirection: Axis.vertical,
    child: SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: ConstrainedBox(
        constraints: BoxConstraints(
          minWidth: MediaQuery.of(context).size.width,
        ),
        child: DataTable(
          headingRowColor: MaterialStateProperty.resolveWith<Color>(
            (Set<MaterialState> states) => const Color.fromARGB(255, 8, 72, 150),
          ),
          headingTextStyle: _headerStyle,
          columnSpacing: 10,
          dataRowColor: MaterialStateProperty.resolveWith<Color>((states) {
            if (states.contains(MaterialState.selected)) {
              return Colors.blue.withOpacity(0.2);
            }
            return Colors.white;
          }),
          sortColumnIndex: _sortColumnIndex == 0 ? null : _sortColumnIndex,
          sortAscending: _sortAscending,
          showCheckboxColumn: false,
          columns: [
            DataColumn(label: const Text('S.No')),
            DataColumn(
              label: const Text('Name'),
              onSort: (columnIndex, ascending) => _onSort(1, ascending),
            ),
            DataColumn(
              label: const Text('Email'),
              onSort: (columnIndex, ascending) => _onSort(2, ascending),
            ),
            DataColumn(
              label: const Text('Phone'),
              onSort: (columnIndex, ascending) => _onSort(3, ascending),
            ),
            DataColumn(
              label: const Text('Address'),
              onSort: (columnIndex, ascending) => _onSort(4, ascending),
            ),
            DataColumn(
              label: const Text('Company Type'),
              onSort: (columnIndex, ascending) => _onSort(5, ascending),
            ),
            DataColumn(label: const Text('Actions')),
          ],
          rows: visibleCustomers.asMap().entries.map((entry) {
            final int index = entry.key;
            final Customer customer = entry.value;
            final bool isSelected = _selectedCustomerIds.contains(customer.id);

            return DataRow(
              selected: isSelected,
              onSelectChanged: (selected) {
                setState(() {
                  if (selected == true) {
                    _selectedCustomerIds
                      ..clear()
                      ..add(customer.id);
                  } else {
                    _selectedCustomerIds.remove(customer.id);
                  }
                });
              },
              cells: [
                DataCell(Text('${startIndex + index + 1}')),
                DataCell(Text(customer.name)),
                DataCell(Text(customer.email ?? '-')),
                DataCell(Text(customer.phone ?? '-')),
                DataCell(
                  SizedBox(
                    width: 200,
                    child: Text(
                      customer.contactAddress.replaceAll('\n', ', '),
                      overflow: TextOverflow.ellipsis,
                      maxLines: 2,
                    ),
                  ),
                ),
                DataCell(Row(
                  children: [
                    Icon(
                      customer.companyType == 'company' ? Icons.business : Icons.person,
                      size: 18,
                      color: customer.companyType == 'company' ? Colors.blue : Colors.green,
                    ),
                    const SizedBox(width: 6),
                    Text(
                      '${customer.companyType[0].toUpperCase()}${customer.companyType.substring(1).toLowerCase()}',
                      style: const TextStyle(fontFamily: 'Arial'),
                    ),
                  ],
                )),
                DataCell(Row(
                  children: [
                    IconButton(
                      icon: const Icon(Icons.edit, color: Colors.blue),
                      tooltip: 'Edit Customer',
                      onPressed: () async {
                        final updatedCustomer = await showDialog(
                          context: context,
                          builder: (_) => EditCustomerPage(customer: customer, posConfig: customer.posConfig),
                        );
                        if (updatedCustomer is Customer) {
                          final idx = customers.indexWhere((c) => c.id == updatedCustomer.id);
                          if (idx != -1) {
                            setState(() {
                              customers[idx] = updatedCustomer;
                            });
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(content: Text('Customer "${updatedCustomer.name}" updated.'), backgroundColor: Colors.green),
                            );
                          }
                        }
                      },
                    ),
                    IconButton(
                      icon: const Icon(Icons.delete, color: Colors.red),
                      tooltip: 'Delete Customer',
                      onPressed: () => _confirmDeleteCustomer(customer),
                    ),
                  ],
                )),
              ],
            );
          }).toList(),
        ),
      ),
    ),
  ),
),

                  // --- Pagination controls (Footer) ---
                  if (!isLoading && totalFilteredCustomers > 0)
                    _buildFooter(
                      totalFilteredCustomers,
                      startIndex,
                      endIndex,
                      totalPages,
                    ),
                ],
              ),
            ),
    );
  
  }

  Widget _buildFooter(int total, int start, int end, int totalPages) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: const BorderRadius.vertical(bottom: Radius.circular(8)),
        border: Border.all(color: Colors.grey.shade300, width: 1),
      ),
      child: Row(
        children: [
          Row(
            children: [
              const Text("Rows per page:", style: TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87)),
              const SizedBox(width: 8),
              DropdownButton<int>(
                value: rowsPerPage,
                items: [5, 10, 20, 50].map((e) {
                  return DropdownMenuItem(value: e, child: Text(e.toString(), style: const TextStyle(fontFamily: 'Arial')));
                }).toList(),
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      rowsPerPage = value;
                      currentPage = 0; // Reset page when rows per page changes
                      _selectedCustomerIds.clear(); // Clear selections on rows per page change
                    });
                  }
                },
                style: const TextStyle(fontFamily: 'Arial', color: Colors.black87),
                icon: const Icon(Icons.arrow_drop_down, color: Color.fromARGB(255, 1, 129, 91)),
                underline: const SizedBox(),
              ),
            ],
          ),
          const Spacer(),
          Text("${start + 1}â€“$end of $total", style: const TextStyle(fontFamily: 'Arial', fontSize: 13, color: Colors.black87)),
          IconButton(
            icon: const Icon(Icons.chevron_left),
            onPressed: currentPage > 0
                ? () => setState(() {
                      currentPage--;
                      _selectedCustomerIds.clear(); // Clear selections on page navigation
                    })
                : null,
            color: const Color.fromARGB(255, 1, 129, 91),
            disabledColor: Colors.grey[400],
          ),
          IconButton(
            icon: const Icon(Icons.chevron_right),
            onPressed: (currentPage + 1) < totalPages
                ? () => setState(() {
                      currentPage++;
                      _selectedCustomerIds.clear(); // Clear selections on page navigation
                    })
                : null,
            color: const Color.fromARGB(255, 1, 129, 91),
            disabledColor: Colors.grey[400],
          ),
        ],
      ),
    );
  }
   Widget _buildCompanyFilterDropdown() {
    return Container(
      height: 40,
      padding: const EdgeInsets.symmetric(horizontal: 5),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(6),
        border: Border.all(color: Colors.white, width: 0.8),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: _companyFilter,
          dropdownColor: Colors.white,
          icon: const Icon(Icons.arrow_drop_down, color: Colors.white, size: 24),
          selectedItemBuilder: (BuildContext context) {
            return <String>['all', 'person', 'company'].map<Widget>((String itemValue) {
              return Align(
                alignment: Alignment.centerLeft,
                child: Text(
                  itemValue.toUpperCase(),
                  style: const TextStyle(
                    color: Colors.white,
                    fontFamily: 'Arial',
                    fontSize: 14,
                  ),
                  overflow: TextOverflow.ellipsis,
                ),
              );
            }).toList();
          },
          items: const [
            DropdownMenuItem(value: 'all', child: Text('All', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
            DropdownMenuItem(value: 'person', child: Text('Person', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
            DropdownMenuItem(value: 'company', child: Text('Company', style: TextStyle(color: Colors.black, fontFamily: 'Arial'))),
          ],
          onChanged: (value) {
            if (value != null) {
              setState(() {
                _companyFilter = value;
                currentPage = 0;
                _selectedCustomerIds.clear();
              });
            }
          },
        ),
      ),
    );
  }
Widget _buildCreditCustomersButton() {
    return ElevatedButton.icon(
      onPressed: () {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (context) => const CreditCustomersPage()),
        );
      },
      style: ElevatedButton.styleFrom(
        foregroundColor: Colors.black, // Text/icon color
        backgroundColor: Colors.white, // Match dropdown background
        elevation: 0,
        side: const BorderSide(color: Colors.grey), // Match dropdown border
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6), // Slight curve like dropdown
        ),
        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 10),
        minimumSize: const Size(180, 48), // Match dropdown height
      ),
      icon: const Icon(Icons.credit_score, size: 20, color: Color.fromARGB(255, 4, 83, 63)),
      label: const Text(
        'Credit Customers',
        style: TextStyle(
          color: Color.fromARGB(255, 4, 83, 63),
          fontSize: 15,
          fontWeight: FontWeight.bold,
          fontFamily: 'Arial',
        ),
      ),
    );
  }


}










import 'package:sqlite3/sqlite3.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'dart:io';

class POSConfigSQLiteHelper {
  static final POSConfigSQLiteHelper instance = POSConfigSQLiteHelper._privateConstructor();
  static Database? _db;

  POSConfigSQLiteHelper._privateConstructor();

  Future<Database> get database async {
    if (_db != null) return _db!;
    _db = await _initDB();
    return _db!;
  }

  Future<Database> _initDB() async {
    final documentsDir = await getApplicationDocumentsDirectory();
    final path = p.join(documentsDir.path, 'posconfig.db');
    final db = sqlite3.open(path);

    db.execute('''
      CREATE TABLE IF NOT EXISTS pos_config (
        id INTEGER PRIMARY KEY,
        name TEXT,
        shop_phone_no TEXT,
        shop_addrs TEXT,
        last_session_closing_cash REAL,
        last_session_closing_date TEXT,
        current_session_state INTEGER,
        shop_gst_no TEXT,
        shop_owner_id INTEGER,
        shop_owner_name TEXT
      )
    ''');

    return db;
  }

  // ðŸ” Insert multiple configs
Future<void> insertConfigs(List<Map<String, dynamic>> configs) async {
  final db = await database;

  for (final config in configs) {
    // Check local current_session_state if exists
    final local = db.select('SELECT current_session_state FROM pos_config WHERE id = ?', [config['id']]);
    int localSessionState = local.isNotEmpty ? local.first['current_session_state'] as int : 0;

    db.execute('''
      INSERT OR REPLACE INTO pos_config (
        id, name, shop_phone_no, shop_addrs, last_session_closing_cash,
        last_session_closing_date, current_session_state, shop_gst_no,
        shop_owner_id, shop_owner_name
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', [
      config['id'],
      config['name'],
      config['shop_phone_no'],
      config['shop_addrs'],
      config['last_session_closing_cash'],
      config['last_session_closing_date'],
      // Use local session state if exists, else fallback to API value
      localSessionState != 0 ? localSessionState : ((config['current_session_state'] == true || config['current_session_state'] == 'opened') ? 1 : 0),
      config['shop_gst_no'],
  config['shop_owner_id'] is Map ? config['shop_owner_id']['id'] : config['shop_owner_id'],
  config['shop_owner_id'] is Map ? config['shop_owner_id']['name'] : config['shop_owner_name'],   ]);
  }

}

Future<List<Map<String, dynamic>>> getAllConfigs() async {
  final db = await database;
  final result = db.select('SELECT * FROM pos_config');

  // Convert each row to Map manually
  return result.map((row) {
    return {
      'id': row['id'],
      'name': row['name'],
      'shop_phone_no': row['shop_phone_no'],
      'shop_addrs': row['shop_addrs'],
      'last_session_closing_cash': row['last_session_closing_cash'],
      'last_session_closing_date': row['last_session_closing_date'],
      'current_session_state': row['current_session_state'],
      'shop_gst_no': row['shop_gst_no'],
      'shop_owner_id': row['shop_owner_id'],
      'shop_owner_name': row['shop_owner_name'],
    };
  }).toList();
}

Future<Map<String, dynamic>?> getConfigById(int id) async {
  final db = await database;
  final result = db.select('SELECT * FROM pos_config WHERE id = ? LIMIT 1', [id]);
  if (result.isEmpty) return null;
  final row = result.first;
  return {
    'id': row['id'],
    'name': row['name'],
    'current_session_state': row['current_session_state'],
    // add other fields as needed
  };
}

  // âŒ Optional: clear all
  Future<void> clearConfigs() async {
    final db = await database;
    db.execute('DELETE FROM pos_config');
  }


void _printLocalPOSConfigs() async {
  try {
    final configs = await POSConfigSQLiteHelper.instance.getAllConfigs();

    for (var config in configs) {
      print('--- POS Config ---');
      print('ID: ${config['id']}');
      print('Name: ${config['name']}');
      print('Phone: ${config['shop_phone_no']}');
      print('Address: ${config['shop_addrs']}');
      print('Closing Cash: ${config['last_session_closing_cash']}');
      print('Closing Date: ${config['last_session_closing_date']}');
      print('Session State: ${config['current_session_state']}');
      print('GST No: ${config['shop_gst_no']}');
      print('Owner ID: ${config['shop_owner_id']}');
      print('Owner Name: ${config['shop_owner_name']}');
    }

    if (configs.isEmpty) {
      print('âš ï¸ No POS config data found in local database.');
    }
  } catch (e) {
    print('âŒ Error printing POS configs: $e');
  }
}
Future<void> printLocalPOSConfigs() async {
  final configs = await getAllConfigs();
  for (var config in configs) {
    print(config);
  }
}

  // New method to update session state and last_session_closing_cash for a config by id
Future<void> updateSessionState(int id, int state) async {
  final db = await database;  // Use `await database` to ensure DB is initialized
  db.execute(
    'UPDATE pos_config SET current_session_state = ? WHERE id = ?',
    [state, id],
  );
}
Future<void> updateClosingCashAndDate(int id, double cash, DateTime date) async {
  final db = await database;
  final dateString = date.toIso8601String();
  db.execute(
    'UPDATE pos_config SET last_session_closing_cash = ?, last_session_closing_date = ? WHERE id = ?',
    [cash, dateString, id],
  );
}



}











import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:dotted_line/dotted_line.dart';
import 'package:rcspos/localdb/purchaseDbHelper.dart';
import 'package:rcspos/screens/home.dart';

const double A4_WIDTH_IN_INCHES = 8.27;
const double DPI = 72.0;

class InvoicePage extends StatelessWidget {
  final String orderId;
    final double total;
  final double gst;
  final Map<String, dynamic> posConfig;
  final List<Map<String, dynamic>> cart;
  final String customerName;
  final String customerPhone;
   final String paymentMode;
  final double paidCash;
  final double paidBank;
    final double paidCard;

  const InvoicePage({
    super.key,
     required this.paymentMode,
    required this.paidCash,
    required this.paidBank,
    required this.paidCard,
     required this.total,
    required this.gst,
    required this.orderId,
    required this.posConfig,
    required this.cart,
    required this.customerName,
    required this.customerPhone,
  });

  TableRow _buildTableRow(List<String> cells, {bool isHeader = false}) {
    return TableRow(
      decoration: BoxDecoration(color: isHeader ? Colors.grey[300] : null),
      children: cells.map((cell) {
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 4),
          child: Text(
            cell,
            style: TextStyle(
              fontWeight: isHeader ? FontWeight.bold : FontWeight.normal,
              fontFamily: 'Courier',
              fontSize: 12,
            ),
            textAlign: TextAlign.center,
          ),
        );
      }).toList(),
    );
  }

  TableRow _buildTaxTableRow(List<String> cells, {bool isHeader = false, bool isTotalRow = false}) {
    return TableRow(
      decoration: BoxDecoration(color: isTotalRow ? Colors.grey[200] : null),
      children: cells.map((cell) {
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 4),
          child: Text(
            cell,
            style: TextStyle(
              fontWeight: isHeader || isTotalRow ? FontWeight.bold : FontWeight.normal,
              fontFamily: 'Courier',
              fontSize: isTotalRow ? 13 : 12,
            ),
            textAlign: TextAlign.right,
          ),
        );
      }).toList(),
    );
  }

  @override
  Widget build(BuildContext context) {
    final invoiceNumber = 'INV${DateTime.now().millisecondsSinceEpoch.toString().substring(5)}';
    final invoiceDate = DateFormat('yyyy-MM-dd â€“ kk:mm').format(DateTime.now());
    final subtotal = cart.fold(0.0, (sum, item) => sum + (item['list_price'] * item['quantity']));
    final sgstRate = 0.05;
    final cgstRate = 0.05;
    final sgstAmount = subtotal * sgstRate;
    final cgstAmount = subtotal * cgstRate;
    final totalTaxAmount = sgstAmount + cgstAmount;
    final total = subtotal + totalTaxAmount;
    final totalItems = cart.fold<int>(0, (sum, item) => sum + item['quantity'] as int);
    final pagePixelWidth = A4_WIDTH_IN_INCHES * DPI;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Invoice', style: TextStyle(color: Colors.white)),
        backgroundColor: const Color.fromARGB(255, 1, 139, 82),
        iconTheme: const IconThemeData(color: Colors.white),
        actions: [
 IconButton(
  icon: const Icon(Icons.shopping_bag), // or any icon you use for order
  tooltip: 'New Order',
  onPressed: () async {
    final dbHelper = PurchaseDBHelper();
    final now = DateTime.now();
    final purchaseId = 'PUR${now.millisecondsSinceEpoch.toString().substring(5)}';
    final purchaseDate = now.toIso8601String();

    final purchase = {
      'order_id': orderId,
      'purchase_id': purchaseId,
      'purchase_date': purchaseDate,
      'supplier_name': customerName,
      'supplier_phone': customerPhone,
      'total_amount': total,
      'total_items_qty': totalItems,
      'sgst_amount': sgstAmount,
      'cgst_amount': cgstAmount,
      'total_tax_amount': totalTaxAmount,
      'status': 'completed',
      'pos_config_name': posConfig['name'],
      'pos_config_address': posConfig['shop_addrs'],
      'pos_config_phone': posConfig['shop_phone_no'],
      'recorded_by': posConfig['shop_owner_id']?['name'] ?? 'Admin',
      'payment_method': 'Cash',
      'discount_amount': 0.0,
      'notes': 'Auto-generated purchase from POS',
    };

    final items = cart.map((item) => {
      'product_id': item['id'],
      'product_name': item['display_name'],
      'quantity': item['quantity'],
      'price_per_unit': item['list_price'],
      'item_total': (item['list_price'] ?? 0.0) * (item['quantity'] ?? 0),
    }).toList();

    final result = await dbHelper.insertPurchase(purchase, items);
    if (result != -1) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Purchase saved âœ…')),
      );

      await dbHelper.printPurchaseData(result);

      // âœ… Navigate to purchase details page if required

              Navigator.pushReplacement(
                context,
                MaterialPageRoute(builder: (context) => HomePage(posConfig: posConfig)),
              );
     
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Failed to save âŒ')),
      );
    }
  },
),

          IconButton(
            icon: const Icon(Icons.print),
            tooltip: 'Print',
            onPressed: () async {
              final dbHelper = PurchaseDBHelper();
              final now = DateTime.now();
              final purchaseId = 'PUR${now.millisecondsSinceEpoch.toString().substring(5)}';
              final purchaseDate = now.toIso8601String();

              final purchase = {
                'order_id': orderId,
                'purchase_id': purchaseId,
                'purchase_date': purchaseDate,
                'supplier_name': customerName,
                'supplier_phone': customerPhone,
                'total_amount': total,
                'total_items_qty': totalItems,
                'sgst_amount': sgstAmount,
                'cgst_amount': cgstAmount,
                'total_tax_amount': totalTaxAmount,
                'status': 'completed',
                'pos_config_name': posConfig['name'],
                'pos_config_address': posConfig['shop_addrs'],
                'pos_config_phone': posConfig['shop_phone_no'],
                'recorded_by': posConfig['shop_owner_id']?['name'] ?? 'Admin',
                'payment_method': 'Cash',
                'discount_amount': 0.0,
                'notes': 'Auto-generated purchase from POS',
              };

              final items = cart.map((item) => {
                    'product_id': item['id'],
                    'product_name': item['display_name'],
                    'quantity': item['quantity'],
                    'price_per_unit': item['list_price'],
                    'item_total': (item['list_price'] ?? 0.0) * (item['quantity'] ?? 0),
                  }).toList();

              final result = await dbHelper.insertPurchase(purchase, items);
              if (result != -1) {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Purchase saved âœ…')));
                await dbHelper.printPurchaseData(result);
              } else {
                ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Failed to save âŒ')));
              }
            },
          ),
        ],
      ),
      body: Center(
        child: Column(
          children: [
            const SizedBox(height: 40),
            Expanded(
              child: SingleChildScrollView(
                child: SizedBox(
                  width: pagePixelWidth,
                  child: Container(
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      border: Border.all(color: Colors.grey.shade400),
                      boxShadow: [BoxShadow(color: Colors.grey.withOpacity(0.4), blurRadius: 6)],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Center(
                          child: Column(
                            children: [
                              Text(posConfig['name'] ?? 'Shop Name',
                                  style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                              Text(posConfig['shop_addrs'] ?? '', style: const TextStyle(fontSize: 12)),
                              Text(posConfig['shop_phone_no']?.toString() ?? '', style: const TextStyle(fontSize: 12)),
                              const Padding(
                                padding: EdgeInsets.symmetric(vertical: 8.0),
                                child: DottedLine(dashColor: Colors.black54),
                              ),
                              Text("Served by ${posConfig['shop_owner_id']?['name'] ?? 'Admin'}",
                                  style: const TextStyle(fontSize: 12)),
                            ],
                          ),
                        ),
                        const SizedBox(height: 20),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text('Bill No: $invoiceNumber', style: const TextStyle(fontSize: 12)),
                            // Text('Order Ref: $orderId', style: const TextStyle(fontSize: 12)),
                            Text('Date: $invoiceDate', style: const TextStyle(fontSize: 12)),
                          ],
                        ),
                        const SizedBox(height: 10),
                        const DottedLine(dashColor: Colors.black54),
                        const SizedBox(height: 20),
                        Table(
                          border: TableBorder.all(color: Colors.grey.shade300),
                          columnWidths: const {
                            0: FlexColumnWidth(3),
                            1: FlexColumnWidth(1.5),
                            2: FlexColumnWidth(2),
                            3: FlexColumnWidth(2),
                          },
                          children: [
                            _buildTableRow(['Item', 'Qty', 'Price', 'Total'], isHeader: true),
                            ...cart.map((item) {
                              final name = item['display_name'] ?? 'Item';
                              final qty = '${item['quantity']}';
                              final price = 'â‚¹${(item['list_price'] ?? 0.0).toStringAsFixed(2)}';
                              final total = 'â‚¹${((item['list_price'] ?? 0.0) * (item['quantity'] ?? 0)).toStringAsFixed(2)}';
                              return _buildTableRow([name, qty, price, total]);
                            }).toList(),
                          ],
                        ),
                        const SizedBox(height: 20),
                        Align(
                          alignment: Alignment.centerRight,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  const Text('Net Total:', style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600)),
                                  Text('â‚¹${subtotal.toStringAsFixed(2)}',
                                      style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                                ],
                              ),
                              const DottedLine(dashColor: Colors.grey),
                            ],
                          ),
                        ),
                        Align(
                          alignment: Alignment.centerRight,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Text('Total Items: $totalItems', style: const TextStyle(fontWeight: FontWeight.bold)),
                              Text('Subtotal: â‚¹${subtotal.toStringAsFixed(2)}'),
                            ],
                          ),
                        ),
                        const SizedBox(height: 20),
                        Center(
                          child: Column(
                            children: [
                              const DottedLine(dashColor: Colors.black54),
                              const Text('Inclusive of GST TAX ', style: TextStyle(fontSize: 12)),
                              const Text('GST Summary - Details',
                                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600)),
                              const SizedBox(height: 10),
                              Table(
                                border: TableBorder.all(color: Colors.grey.shade300),
                                columnWidths: const {
                                  0: FlexColumnWidth(3),
                                  1: FlexColumnWidth(2),
                                  2: FlexColumnWidth(2),
                                  3: FlexColumnWidth(2),
                                },
                                children: [
                                  _buildTaxTableRow(['Tax', 'Amount', 'Base', 'Total'], isHeader: true),
                                  _buildTaxTableRow([
                                    'SGST 5%',
                                    sgstAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    (subtotal + sgstAmount).toStringAsFixed(2),
                                  ]),
                                  _buildTaxTableRow([
                                    'CGST 5%',
                                    cgstAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    (subtotal + cgstAmount).toStringAsFixed(2),
                                  ]),
                                  _buildTaxTableRow([
                                    '',
                                    totalTaxAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    total.toStringAsFixed(2),
                                  ], isTotalRow: true),
                                ],
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 30),
                        Center(
                          child: Column(
                            children: const [
                              Text('powered by RCS', style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
                              Text('____________________________'),
                              Text('Note: Thank you for your business!',
                                  style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}





import 'dart:convert';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:dotted_line/dotted_line.dart';
import 'package:intl/intl.dart';
import 'dart:io';
import 'package:rcspos/localdb/orders_sqlite_helper.dart';
import 'package:rcspos/localdb/purchaseDbHelper.dart';
import 'package:rcspos/screens/home.dart';
import 'package:rcspos/utils/urls.dart';
const double A4_WIDTH_IN_INCHES = 8.27;
const double DPI = 72.0;

class InvoicePage extends StatefulWidget {
  final List<Map<String, dynamic>> cart;
  final int productId;
  final double total;
  final double paidCash;
  final double paidCard;
  final double paidBank;
  final double sgstAmount;
  final double cgstAmount;
  final double totalTaxAmount;
  final String paymentMode;
  final String customerName;
  final String customerPhone;
  final Map<String, dynamic> posConfig;
  final int posId;
  final String orderId;
  final dynamic sessionState;

  const InvoicePage({
    super.key,
    required this.cart,
    required this.total,
    required this.productId,
    required this.paidCash,
    required this.paidCard,
    required this.paidBank,
    required this.sgstAmount,
     required this.cgstAmount,
    required this.totalTaxAmount,
    required this.paymentMode,
    required this.customerName,
    required this.customerPhone,
    required this.posConfig,
    required this.posId,
    required this.orderId,
    required this.sessionState,
  });


  @override
  _InvoicePageState createState() => _InvoicePageState();

}

class _InvoicePageState extends State<InvoicePage> {
 
 @override

@override
void initState() {
  super.initState();
  initializeSession(); // async logic goes here
}

Future<void> initializeSession() async {
  final box = await Hive.openBox('login');
  final rawSession = box.get('session_id');

  // Validate session presence
  if (rawSession == null || (rawSession as String).trim().isEmpty) {
    debugPrint("âŒ No session ID available for posting order.");
    return;
  }

  final sessionId = rawSession.startsWith('session_id=')
      ? rawSession
      : 'session_id=$rawSession';

  if (sessionId.isNotEmpty) {
    debugPrint("âœ… Session ID: $sessionId");
    syncUnsyncedOrders(); // Call your sync logic
    listenToConnectivityChanges(); // Monitor connectivity
  } else {
    debugPrint("âŒ Error: session_id is null or empty");
  }
}

void listenToConnectivityChanges() {
  Connectivity().onConnectivityChanged.listen((result) {
   if (result != ConnectivityResult.none) {
  syncUnsyncedOrders(); // âœ… Pass the sessionId here too
}

  });
}




Future<void> syncUnsyncedOrders() async {
  final dbHelper = PurchaseDBHelper();
  final unsyncedOrders = await dbHelper.getUnsyncedPurchases();

  final box = await Hive.openBox('login');
  final rawSession = box.get('session_id');

  // Validate session presence
  if (rawSession == null || (rawSession as String).trim().isEmpty) {
    debugPrint("âŒ No session ID available for posting order.");
    return;
  }

  final sessionId = rawSession.startsWith('session_id=')
      ? rawSession
      : 'session_id=$rawSession';

  print("ðŸŸ¡ Unsynced Purchases:");
  for (var order in unsyncedOrders) {
    print(order);
  }

  for (var order in unsyncedOrders) {
  try {
    final response = await http.post(
      Uri.parse('$baseurl/web/dataset/call_kw/pos.order/create_from_ui'),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        HttpHeaders.cookieHeader: sessionId,
        'Cookie': sessionId,
      },
      body: jsonEncode({'params': order}),
    );

    if (response.statusCode == 200) {
      await dbHelper.markPurchaseAsSynced(order['order_id'].toString());
      print("âœ… Order ${order['order_id']} synced");
    } else {
      print("âŒ Failed to sync order ${order['order_id']}: ${response.statusCode} - ${response.body}");
    }
  } catch (e, stack) {
    print("âŒ Exception syncing order ${order['order_id']}: $e\n$stack");
  }
}

}

  Future<bool> isOnline() async {
  var connectivityResult = await Connectivity().checkConnectivity();
  return connectivityResult != ConnectivityResult.none;
}

Future<bool> postOrderToServer(Map<String, dynamic> order) async {
 // Replace with your config
  final url = '$baseurl/web/dataset/call_kw/pos.order/create_from_ui';

  try {
    // Open Hive box for session retrieval
    final box = await Hive.openBox('login');
    final rawSession = box.get('session_id');

    // Validate session presence
    if (rawSession == null || (rawSession as String).trim().isEmpty) {
      debugPrint("No session ID available for posting order.");
      return false;
    }

    final sessionId = (rawSession as String).startsWith('session_id=')
        ? rawSession
        : 'session_id=${rawSession.toString()}';

    // Transform the order data as per Odoo API expectations
    final odooOrder = {
      "jsonrpc": "2.0",
      "method": "call",
      "params": {
        "model": "pos.order",
        "method": "create_from_ui",
        "args": [
          [
            {
              "data": {
                "name": order['order_id'] ?? "Order ${DateTime.now().millisecondsSinceEpoch}",
                "amount_total": order['total']?.toDouble() ?? 0.0,
                "amount_tax": order['total_tax_amount']?.toDouble() ?? 0.0,
                "amount_paid": (order['paid_cash']?.toDouble() ?? 0.0) +
                    (order['paid_card']?.toDouble() ?? 0.0) +
                    (order['paid_bank']?.toDouble() ?? 0.0),
                "amount_return": 0.0,
                "sequence_number": "001",
                "date_order": DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now()),
                "statement_ids": [
                  [
                    0,
                    0,
                    {
                      "amount": (order['paid_cash']?.toDouble() ?? 0.0) +
                          (order['paid_card']?.toDouble() ?? 0.0) +
                          (order['paid_bank']?.toDouble() ?? 0.0),
                      "payment_method_id": _getPaymentMethodId(order['payment_method']),
                      "name": DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now()),
                    }
                  ]
                ],
                "partner_id": 3, // Adjust dynamically if needed
                "session_id": sessionId, // Adjust dynamically if needed
                "pricelist_id": 1,
                "pos_session_id": 1,
                "fiscal_position_id": null,
                "user_id": 8,
                "company_id": 1,
                "lines": order['items']
                        ?.map((item) => [
                              0,
                              0,
                              {
                                "product_id": item['id'] ?? 14,
                                "full_product_name": item['product_name'] ?? "Product",
                                "qty": item['quantity']?.toDouble() ?? 1.0,
                                "price_unit": item['unit_price']?.toDouble() ?? 0.0,
                                "discount": 0.0,
                                "price_subtotal": item['item_total']?.toDouble() ?? 0.0,
                                "price_subtotal_incl": item['item_total']?.toDouble() ?? 0.0,
                              }
                            ])
                        .toList() ??
                    []
              }
            }
          ]
        ],
        "kwargs": {"draft": false}
      },
      "id": 1,
    };

    final response = await http.post(
      Uri.parse(url),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        HttpHeaders.cookieHeader: sessionId,
      },
      body: jsonEncode(odooOrder),
    );

    if (response.statusCode == 200) {
      final responseData = jsonDecode(response.body);
      if (responseData['result'] != null) {
        print('âœ… Order posted successfully: ${response.body}');
        return true;
      } else if (responseData['error'] != null) {
        print('âŒ Odoo Error: ${responseData['error']}');
        return false;
      }
      return true;
    } else {
      print('âŒ HTTP Error ${response.statusCode}: ${response.body}');
      return false;
    }
  } catch (e) {
    print('âŒ Exception posting order: $e');
    return false;
  }
}


  int _getPaymentMethodId(String? paymentMethod) {
    switch (paymentMethod?.toLowerCase()) {
      case 'cash':
        return 1;
      case 'card':
        return 2;
      case 'bank':
        return 3;
      default:
        return 1;
    }
  }
 Future<void> storeOrderLocally(Map<String, dynamic> order, {bool synced = false}) async {
  final db = PurchaseDBHelper();

  final purchaseData = {
    'purchase_id': 'PUR-${DateTime.now().millisecondsSinceEpoch}',
    'purchase_date': DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now()),
    'order_id': order['order_id'] as String,
    'supplier_name': order['customer_name'] ?? '',
    'supplier_phone': order['customer_phone'] ?? '',
    'total_amount': (order['total'] as num?)?.toDouble() ?? 0.0,
    'total_items_qty': order['items']?.length ?? 0,
    'sgst_amount': (order['sgst_amount'] as num?)?.toDouble() ?? 0.0,
    'cgst_amount': (order['cgst_amount'] as num?)?.toDouble() ?? 0.0,
    'total_tax_amount': (order['total_tax_amount'] as num?)?.toDouble() ?? 0.0,
    'status': synced ? 'synced' : 'pending',
    'pos_config_name': order['pos_config_name'] ?? '',
    'pos_config_address': order['pos_config_address'] ?? '',
    'pos_config_phone': order['pos_config_phone'] ?? '',
    'recorded_by': order['recorded_by'] ?? '',
    'payment_method': order['payment_method'] ?? 'Cash',
    'discount_amount': (order['discount_amount'] as num?)?.toDouble() ?? 0.0,
    'notes': 'Order completed via POS',
  };

  final items = (order['items'] as List<dynamic>?)?.map((item) => {
    'product_id': item['product_id'] as int?,
    'product_name': item['product_name'] as String,
    'quantity': item['quantity'] as int,
    'price_per_unit': (item['unit_price'] as num?)?.toDouble() ?? 0.0,
    'item_total': (item['item_total'] as num?)?.toDouble() ?? 0.0,
  }).toList() ?? [];

  await db.insertPurchase(purchaseData, items);
}
void syncPendingOrders() async {
  final online = await isOnline();
  if (!online) return;

  final db = PurchaseDBHelper();
  final pendingOrders = await db.getUnsyncedPurchases(); // Implement this method

  for (final order in pendingOrders) {
    final success = await postOrderToServer(order);
    if (success) {
      await db.markPurchaseAsSynced(order['order_id']); // Update 'status' to 'synced'
    }
  }
}


  @override
  Widget build(BuildContext context) {
         final invoiceNumber = 'INV${DateTime.now().millisecondsSinceEpoch.toString().substring(5)}';
    final invoiceDate = DateFormat('yyyy-MM-dd â€“ kk:mm').format(DateTime.now());
    final subtotal = widget.cart.fold(0.0, (sum, item) => sum + (item['list_price'] * item['quantity']));
    final sgstRate = 0.05;
    final cgstRate = 0.05;
    final sgstAmount = subtotal * sgstRate;
    final cgstAmount = subtotal * cgstRate;
    final totalTaxAmount = sgstAmount + cgstAmount;
    final total = subtotal + totalTaxAmount;
    final totalItems = widget.cart.fold<int>(0, (sum, item) => sum + item['quantity'] as int);
    final pagePixelWidth = A4_WIDTH_IN_INCHES * DPI;


    return Scaffold(
      appBar: AppBar(
        title: const Text('Invoice'),
        actions: [
          IconButton(
            icon: const Icon(Icons.shopping_bag),
            tooltip: 'New Order',
            onPressed: () async {
  final orderData = {
    "order_id": widget.orderId,
    "customer_name": widget.customerName,
    "customer_phone": widget.customerPhone,
    "total": total,
    "sgst_amount": sgstAmount,
    "cgst_amount": cgstAmount,
    "total_tax_amount": totalTaxAmount,
    "payment_method": widget.paymentMode,
    "paid_cash": widget.paidCash,
    "paid_card": widget.paidCard,
    "paid_bank": widget.paidBank,
    "items": widget.cart.map((item) => {
      "product_id": item["id"],
      "product_name": item["display_name"],
      "quantity": item["quantity"],
      "unit_price": item["list_price"],
      "item_total": (item["list_price"] ?? 0.0) * (item["quantity"] ?? 0),
    }).toList(),
    "pos_config_name": widget.posConfig['name'],
    "pos_config_address": widget.posConfig['shop_addrs'],
    "pos_config_phone": widget.posConfig['shop_phone_no'],
    "recorded_by": (widget.posConfig['shop_owner_id'] is Map)
        ? widget.posConfig['shop_owner_id']['name']
        : widget.posConfig['shop_owner_id'].toString()
  };

  final online = await isOnline();

  bool posted = false;
  if (online) {
    posted = await postOrderToServer(orderData);
  }

  await storeOrderLocally(orderData, synced: posted);
const JsonEncoder encoder = JsonEncoder.withIndent('  ');
print(encoder.convert(orderData));

  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(
        posted
            ? "âœ… Order posted to server and saved locally"
            : "ðŸ“´ Offline: Order saved locally",
      ),
    ),
  );

  // Navigate back to home
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => HomePage(
        posConfig: widget.posConfig,
        posId: widget.posId,
        sessionState: widget.sessionState,
      ),
    ),
  );
},
          )
        ],
      ),
      body: Center(
        child: Column(
          children: [
            const SizedBox(height: 40),
            Expanded(
              child: SingleChildScrollView(
                child: SizedBox(
                  width: pagePixelWidth,
                  child: Container(
                    padding: const EdgeInsets.all(24),
                    decoration: BoxDecoration(
                      color: Colors.white,
                      border: Border.all(color: Colors.grey.shade400),
                      boxShadow: [BoxShadow(color: Colors.grey.withOpacity(0.4), blurRadius: 6)],
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Center(
                          child: Column(
                            children: [
                              Text(widget.posConfig['name'] ?? 'Shop Name',
                                  style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
                              Text(widget.posConfig['shop_addrs'] ?? '', style: const TextStyle(fontSize: 12)),
                              Text(widget.posConfig['shop_phone_no']?.toString() ?? '', style: const TextStyle(fontSize: 12)),
                              const Padding(
                                padding: EdgeInsets.symmetric(vertical: 8.0),
                                child: DottedLine(dashColor: Colors.black54),
                              ),
                              Text("Served by ${(widget.posConfig['shop_owner_id'] is Map) 
    ? widget.posConfig['shop_owner_id']['name'] 
    : widget.posConfig['shop_owner_id'].toString()
}",
                                  style: const TextStyle(fontSize: 12)),
                            ],
                          ),
                        ),
                        const SizedBox(height: 20),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text('Bill No: $invoiceNumber', style: const TextStyle(fontSize: 12)),
                            // Text('Order Ref: $orderId', style: const TextStyle(fontSize: 12)),
                            Text('Date: $invoiceDate', style: const TextStyle(fontSize: 12)),
                          ],
                        ),
                        const SizedBox(height: 10),
                        const DottedLine(dashColor: Colors.black54),
                        const SizedBox(height: 20),
                        Table(
                          border: TableBorder.all(color: Colors.grey.shade300),
                          columnWidths: const {
                            0: FlexColumnWidth(3),
                            1: FlexColumnWidth(1.5),
                            2: FlexColumnWidth(2),
                            3: FlexColumnWidth(2),
                          },
                          children: [
                            _buildTableRow(['Item', 'Qty', 'Price', 'Total'], isHeader: true),
                            ...widget.cart.map((item) {
                              final name = item['display_name'] ?? 'Item';
                              final qty = '${item['quantity']}';
                              final price = 'â‚¹${(item['list_price'] ?? 0.0).toStringAsFixed(2)}';
                              final total = 'â‚¹${((item['list_price'] ?? 0.0) * (item['quantity'] ?? 0)).toStringAsFixed(2)}';
                              return _buildTableRow([name, qty, price, total]);
                            }).toList(),
                          ],
                        ),
                        const SizedBox(height: 20),
                        Align(
                          alignment: Alignment.centerRight,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  const Text('Net Total:', style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600)),
                                  Text('â‚¹${subtotal.toStringAsFixed(2)}',
                                      style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                                ],
                              ),
                              const DottedLine(dashColor: Colors.grey),
                            ],
                          ),
                        ),
                        Align(
                          alignment: Alignment.centerRight,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.end,
                            children: [
                              Text('Total Items: $totalItems', style: const TextStyle(fontWeight: FontWeight.bold)),
                              Text('Subtotal: â‚¹${subtotal.toStringAsFixed(2)}'),
                            ],
                          ),
                        ),
                        const SizedBox(height: 20),
                        Center(
                          child: Column(
                            children: [
                              const DottedLine(dashColor: Colors.black54),
                              const Text('Inclusive of GST TAX ', style: TextStyle(fontSize: 12)),
                              const Text('GST Summary - Details',
                                  style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600)),
                              const SizedBox(height: 10),
                              Table(
                                border: TableBorder.all(color: Colors.grey.shade300),
                                columnWidths: const {
                                  0: FlexColumnWidth(3),
                                  1: FlexColumnWidth(2),
                                  2: FlexColumnWidth(2),
                                  3: FlexColumnWidth(2),
                                },
                                children: [
                                  _buildTaxTableRow(['Tax', 'Amount', 'Base', 'Total'], isHeader: true),
                                  _buildTaxTableRow([
                                    'SGST 5%',
                                    sgstAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    (subtotal + sgstAmount).toStringAsFixed(2),
                                  ]),
                                  _buildTaxTableRow([
                                    'CGST 5%',
                                    cgstAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    (subtotal + cgstAmount).toStringAsFixed(2),
                                  ]),
                                  _buildTaxTableRow([
                                    '',
                                    totalTaxAmount.toStringAsFixed(2),
                                    subtotal.toStringAsFixed(2),
                                    total.toStringAsFixed(2),
                                  ], isTotalRow: true),
                                ],
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 30),
                        Center(
                          child: Column(
                            children: const [
                              Text('powered by RCS', style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
                              Text('____________________________'),
                              Text('Note: Thank you for your business!',
                                  style: TextStyle(fontSize: 12, fontStyle: FontStyle.italic)),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );



    
  }

   TableRow _buildTaxTableRow(List<String> cells, {bool isHeader = false, bool isTotalRow = false}) {
    return TableRow(
      decoration: BoxDecoration(color: isTotalRow ? Colors.grey[200] : null),
      children: cells.map((cell) {
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 4),
          child: Text(
            cell,
            style: TextStyle(
              fontWeight: isHeader || isTotalRow ? FontWeight.bold : FontWeight.normal,
              fontFamily: 'Courier',
              fontSize: isTotalRow ? 13 : 12,
            ),
            textAlign: TextAlign.right,
          ),
        );
      }).toList(),
    );
   }

     TableRow _buildTableRow(List<String> cells, {bool isHeader = false}) {
    return TableRow(
      decoration: BoxDecoration(color: isHeader ? Colors.grey[300] : null),
      children: cells.map((cell) {
        return Padding(
          padding: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 4),
          child: Text(
            cell,
            style: TextStyle(
              fontWeight: isHeader ? FontWeight.bold : FontWeight.normal,
              fontFamily: 'Courier',
              fontSize: 12,
            ),
            textAlign: TextAlign.center,
          ),
        );
      }).toList(),
    );
  }
}









import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:sqlite3/sqlite3.dart' as sql;

class PurchaseDBHelper {
  static sql.Database? _db;
  static const _dbName = 'purchase_database.db';

  Future<sql.Database> get database async {
    if (_db != null) return _db!;
    return await _initDB();
  }
Future<sql.Database> _initDB() async {
  final dir = await getApplicationDocumentsDirectory();
  final path = join(dir.path, _dbName);
  final file = File(path);
  final exists = await file.exists();

  if (_db != null) {
    try {
      _db!.dispose();
    } catch (e) {
      debugPrint("âš ï¸ DB dispose error: $e");
    }
    _db = null;
  }

  _db = sql.sqlite3.open(path);

  if (!exists) {
    _createTables(_db!);
  } else {
    // Database already exists - perform schema migrations here
    _migrateDatabase(_db!);
  }

  return _db!;
}


void _migrateDatabase(sql.Database db) {
  try {
    // Add 'synced' column to existing purchases table if not exist
    db.execute('ALTER TABLE purchases ADD COLUMN synced INTEGER DEFAULT 0;');
    debugPrint('âœ… Migrated: Added synced column');
  } catch (e) {
    // Ignore if column already exists (SQLite throws error)
    debugPrint('â„¹ï¸ Migration check or ignored error: $e');
  }
}

  void _createTables(sql.Database db) {
    db.execute('''
      CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        purchase_id TEXT NOT NULL UNIQUE,
        purchase_date TEXT NOT NULL,
        order_id TEXT,
        supplier_name TEXT,
        supplier_phone TEXT,
        total_amount REAL NOT NULL,
        total_items_qty INTEGER NOT NULL,
        sgst_amount REAL DEFAULT 0.0,
        cgst_amount REAL DEFAULT 0.0,
        total_tax_amount REAL DEFAULT 0.0,
        status TEXT DEFAULT 'pending',
        pos_config_name TEXT,
        pos_config_address TEXT,
        pos_config_phone TEXT,
        recorded_by TEXT,
        payment_method TEXT,
        discount_amount REAL DEFAULT 0.0,
        notes TEXT
      );
    ''');

    db.execute('''
      CREATE TABLE IF NOT EXISTS purchase_items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        purchase_detail_id INTEGER NOT NULL,
        product_id INTEGER,
        product_name TEXT NOT NULL,
        quantity INTEGER NOT NULL,
        price_per_unit REAL NOT NULL,
        item_total REAL NOT NULL,
        FOREIGN KEY (purchase_detail_id) REFERENCES purchases(id) ON DELETE CASCADE
      );
    ''');
  }

  Future<int> insertPurchase(
    Map<String, dynamic> purchase,
    List<Map<String, dynamic>> items,
  ) async {
    final db = await database;
    db.execute('BEGIN TRANSACTION;');

    try {
      final purchaseStmt = db.prepare('''
        INSERT INTO purchases (
          purchase_id, purchase_date, order_id, supplier_name, supplier_phone,
          total_amount, total_items_qty, sgst_amount, cgst_amount, total_tax_amount,
          status, pos_config_name, pos_config_address, pos_config_phone, recorded_by,
          payment_method, discount_amount, notes
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      ''');

      purchaseStmt.execute([
        purchase['purchase_id'],
        purchase['purchase_date'],
        purchase['order_id'],
        purchase['supplier_name'],
        purchase['supplier_phone'],
        purchase['total_amount'],
        purchase['total_items_qty'],
        purchase['sgst_amount'] ?? 0.0,
        purchase['cgst_amount'] ?? 0.0,
        purchase['total_tax_amount'] ?? 0.0,
        purchase['status'] ?? 'pending',
        purchase['pos_config_name'],
        purchase['pos_config_address'],
        purchase['pos_config_phone'],
        purchase['recorded_by'],
        purchase['payment_method'],
        purchase['discount_amount'] ?? 0.0,
        purchase['notes'],
      ]);

      final purchaseId = db.lastInsertRowId;
      purchaseStmt.dispose();

      final itemStmt = db.prepare('''
        INSERT INTO purchase_items (
          purchase_detail_id, product_id, product_name, quantity, price_per_unit, item_total
        ) VALUES (?, ?, ?, ?, ?, ?)
      ''');

      for (final item in items) {
        itemStmt.execute([
          purchaseId,
          item['product_id'],
          item['product_name'],
          item['quantity'],
          item['price_per_unit'],
          item['item_total'],
        ]);
      }

      itemStmt.dispose();
      db.execute('COMMIT;');
      return purchaseId;
    } catch (e) {
      db.execute('ROLLBACK;');
      debugPrint('âŒ Insert failed: $e');
      return -1;
    }
  }

  Future<Map<String, dynamic>?> getPurchaseById(int id) async {
    final db = await database;
    final result = db.select('SELECT * FROM purchases WHERE id = ?', [id]);
    if (result.isEmpty) return null;

    final purchase = Map<String, dynamic>.fromIterables(
      result.columnNames,
      List.generate(result.columnNames.length, (i) => result.first.columnAt(i)),
    );

    final items = db.select('SELECT * FROM purchase_items WHERE purchase_detail_id = ?', [id]);

    final itemsList = items.map((row) {
      return Map<String, dynamic>.fromIterables(
        items.columnNames,
        List.generate(items.columnNames.length, (i) => row.columnAt(i)),
      );
    }).toList();

    return {
      'purchase': purchase,
      'items': itemsList,
    };
  }

  Future<Map<String, dynamic>?> getPurchaseByOrderId(String orderId) async {
    final db = await database;
    final result = db.select('SELECT * FROM purchases WHERE order_id = ?', [orderId]);

    if (result.isEmpty) return null;

    final purchase = Map<String, dynamic>.fromIterables(
      result.columnNames,
      List.generate(result.columnNames.length, (i) => result.first.columnAt(i)),
    );

    final items = db.select('SELECT * FROM purchase_items WHERE purchase_detail_id = ?', [purchase['id']]);

    final itemsList = items.map((row) {
      return Map<String, dynamic>.fromIterables(
        items.columnNames,
        List.generate(items.columnNames.length, (i) => row.columnAt(i)),
      );
    }).toList();

    return {
      'purchase': purchase,
      'items': itemsList,
    };
  }

  Future<void> printPurchaseData(int id) async {
    final result = await getPurchaseById(id);
    if (result == null) {
      debugPrint("âŒ Purchase $id not found");
      return;
    }

    final p = result['purchase'];
    final items = result['items'] as List<Map<String, dynamic>>;

    debugPrint("ðŸ§¾ PURCHASE [ID: $id]");
    debugPrint("=" * 90);
    debugPrint("Purchase ID    : ${p['purchase_id']}");
    debugPrint("Order ID       : ${p['order_id']}");
    debugPrint("Date           : ${p['purchase_date']}");
    debugPrint("Supplier Name  : ${p['supplier_name']}");
    debugPrint("Supplier Phone : ${p['supplier_phone']}");
    debugPrint("Shop Name      : ${p['pos_config_name']}");
    debugPrint("Shop Address   : ${p['pos_config_address']}");
    debugPrint("Shop Phone     : ${p['pos_config_phone']}");
    debugPrint("Recorded By    : ${p['recorded_by']}");
    debugPrint("Payment Method : ${p['payment_method']}");
    debugPrint("Status         : ${p['status']}");
    debugPrint("Notes          : ${p['notes'] ?? ''}");
    debugPrint("-" * 90);

    debugPrint("Product                        | Qty | Rate      | Total");
    debugPrint("-" * 90);

    for (final i in items) {
      final name = (i['product_name'] ?? '').toString().padRight(28).substring(0, 28);
      final qty = '${i['quantity']}'.padLeft(3);
      final rate = 'â‚¹${(i['price_per_unit'] ?? 0.0).toStringAsFixed(2)}'.padLeft(8);
      final total = 'â‚¹${(i['item_total'] ?? 0.0).toStringAsFixed(2)}'.padLeft(8);
      debugPrint("$name | $qty | $rate | $total");
    }

    debugPrint("-" * 90);
    debugPrint("Subtotal       : â‚¹${((p['total_amount'] ?? 0.0) - (p['total_tax_amount'] ?? 0.0)).toStringAsFixed(2)}");
    debugPrint("SGST Amount    : â‚¹${(p['sgst_amount'] ?? 0.0).toStringAsFixed(2)}");
    debugPrint("CGST Amount    : â‚¹${(p['cgst_amount'] ?? 0.0).toStringAsFixed(2)}");
    debugPrint("Total GST      : â‚¹${(p['total_tax_amount'] ?? 0.0).toStringAsFixed(2)}");
    debugPrint("Final Amount   : â‚¹${(p['total_amount'] ?? 0.0).toStringAsFixed(2)}");
    debugPrint("Total Items    : ${p['total_items_qty']}");
    debugPrint("=" * 90);
  }

Future<List<Map<String, dynamic>>> getUnsyncedPurchases() async {
  final db = await database;
  final result = db.select('SELECT * FROM purchases WHERE synced = 0 OR synced IS NULL');

  final List<Map<String, dynamic>> purchases = [];

  for (final row in result) {
    final rowMap = <String, dynamic>{};
    for (final column in row.keys) {
      rowMap[column] = row[column];
    }
    purchases.add(rowMap);
  }

  return purchases;
}

Future<void> markPurchaseAsSynced(String orderId) async {
  final db = await database;
  final stmt = db.prepare(
    'UPDATE purchases SET synced = 1, status = ? WHERE order_id = ?',
  );
  stmt.execute(['synced', orderId]);
  stmt.dispose();
}




  Future<void> close() async {
    if (_db != null) {
      _db!.dispose();
      _db = null;
    }
  }
  Future<void> deleteAllPurchases() async {
  final db = await database;

  db.execute('BEGIN TRANSACTION;');

  try {
    db.execute('DELETE FROM purchase_items;');
    db.execute('DELETE FROM purchases;');
    db.execute('COMMIT;');
    debugPrint('ðŸ—‘ï¸ All purchase data deleted');
  } catch (e) {
    db.execute('ROLLBACK;');
    debugPrint('âŒ Failed to delete purchase data: $e');
  }
}

}






// file: posconfigpage.dart

import 'dart:convert';
import 'dart:io'; // For HttpHeaders
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/components/snackbar_helper.dart';
import 'package:rcspos/localdb/posconfigsqlitehelper.dart';

import 'package:rcspos/screens/home.dart'; // Make sure this path is correct
import 'package:rcspos/screens/loginpage.dart';

import 'package:rcspos/screens/open_session_dialog.dart';
import 'package:rcspos/utils/urls.dart'; // Make sure baseurl is correctly defined here
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';


class POSConfigPage extends StatefulWidget {   

    const POSConfigPage({ 
    super.key,

  });

  @override
  State<POSConfigPage> createState() => _POSConfigPageState();
}

class _POSConfigPageState extends State<POSConfigPage> {
  
  bool _loading = true;
  List<Map<String, dynamic>> _configs = [];
  String? _errorMessage; // Added for specific error messages

  final String apiUrl =
      '$baseurl/api/pos.config/?query={id,name,shop_phone_no,shop_code,shop_addrs,last_session_closing_cash,last_session_closing_date,current_session_state,shop_gst_no,shop_phone_no,shop_owner_id{id,name}}';

  @override
  void initState() {
    super.initState();
    fetchPOSConfigs();
    
  }

Future<void> fetchPOSConfigs() async {
  setState(() {
    _loading = true;
    _errorMessage = null;
  });

  final box = await Hive.openBox('login');
  final sqlite = posConfigSQLiteHelper.instance;

  try {
    final rawSession = box.get('session_id');

    if (rawSession == null || (rawSession as String).trim().isEmpty) {
      showError('Session ID not found. Please login again.');
      return;
    }

    final sessionId = rawSession.startsWith('session_id=')
        ? rawSession
        : 'session_id=$rawSession';
    debugPrint('Using sessionId: $sessionId');

    final response = await http.get(
      Uri.parse(apiUrl),
      headers: {
        HttpHeaders.cookieHeader: sessionId,
        HttpHeaders.contentTypeHeader: 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      final List configsRaw = data['result'] ?? [];

      if (configsRaw.isEmpty) {
        showError("No POS configurations found in the API response.");
        setState(() => _configs = []);
        return;
      }

      final List<Map<String, dynamic>> parsedConfigs =
          configsRaw.map((e) => Map<String, dynamic>.from(e)).toList();

      // Insert or update local DB
      await sqlite.insertConfigs(parsedConfigs);

      // Fetch updated data from local DB
      final updatedConfigs = await sqlite.getAllConfigs();
      print("âœ… Number of configs fetched from DB: ${updatedConfigs.length}");
      for (var config in updatedConfigs) {
        print("ðŸ”¹ Config: $config");
      }

      setState(() {
        _configs = updatedConfigs;
      });
    } else {
      final error = jsonDecode(response.body);
      final msg = error['error']?['data']?['message'] ?? response.body;

      showError("API Error: ${response.statusCode} - $msg");

      final offlineData = await sqlite.getAllConfigs();
      if (offlineData.isNotEmpty) {
        setState(() => _configs = offlineData);
        showCustomSnackBar(
          context: context,
          title: "Using Offline Data",
          message: "Showing cached POS configurations.",
          backgroundColor: Colors.orange,
          icon: Icons.cloud_off,
        );
      } else {
        setState(() => _configs = []);
        showError("No offline POS configs available.");
      }
    }
  } catch (e, stackTrace) {
    debugPrint("âŒ Exception during fetch: $e\n$stackTrace");

    final offlineData = await sqlite.getAllConfigs();
    if (offlineData.isNotEmpty) {
      setState(() => _configs = offlineData);
      showCustomSnackBar(
        context: context,
        title: "Offline Mode",
        message: "API failed. Loaded local POS configs.",
        backgroundColor: Colors.orange,
        icon: Icons.wifi_off,
      );
    } else {
      setState(() => _configs = []);
      showError("Offline Fetch Failed: No local POS configs available.");
    }
  } finally {
    setState(() => _loading = false);
  }
}
  
  String _formatDate(String value) {
    try {
      final date = DateTime.tryParse(value);
      if (date != null) {
        return '${date.day.toString().padLeft(2, '0')}-${date.month.toString().padLeft(2, '0')}-${date.year}';
      }
    } catch (_) {
      // Handle parsing errors gracefully
    }
    return 'N/A';
  }
  // --- Error Message Handler ---
  void showError(String message) {
    setState(() {
      _loading = false;
      _errorMessage = message; // Store the error message
    });
    // Also show a SnackBar for immediate feedback
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message)));
  }

  // --- Status Color and Text Helpers ---
  Color getStatusColor(dynamic status) {
    if (status == true) return Colors.green.shade600; // Slightly darker green
    if (status == false) return Colors.red.shade600; // Slightly darker red
    return Colors.grey.shade600; // Consistent grey
  }

  String getStatusText(dynamic status) {
    if (status == true) return 'In Progress';
    if (status == false) return 'Closed';
    return 'Unknown';
  }

  // --- UI Build Method ---
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Point Of Sale',
          style: TextStyle(
            fontFamily: 'Arial',
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
         flexibleSpace: Container(
    decoration: const BoxDecoration(
      gradient: LinearGradient(
        colors: [Color.fromARGB(255, 44, 145, 113), Color(0xFF185A9D)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
    ),
  ),
        backgroundColor: Colors.transparent,
        iconTheme: const IconThemeData(color: Colors.white),
        actions: [
          IconButton(
            icon: const Icon(Icons.exit_to_app),
            tooltip: 'Logout',
            onPressed: () {
             
              Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => const Login()), // Removed posConfig
                (route) => false,
              );

              
            },
          ),
        ],
      ),
      backgroundColor: const Color(0xFFF7F4FB),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null // Show error widget if there's an error
              ? _buildErrorWidget()
              : _configs.isEmpty
                  ? _buildNoConfigsWidget() // Show no configs widget if list is empty
                  : SingleChildScrollView(
                      padding: const EdgeInsets.all(5),
                      child: LayoutBuilder(
                        builder: (context, constraints) {
                          int crossAxisCount = 1;
                          // Increase childAspectRatio for mobile and tablets
                          double childAspectRatio = 1.2; // Increased from 1.6
                          if (constraints.maxWidth > 800) {
                            crossAxisCount = 3;
                            childAspectRatio = 1.3; // Can keep as is or adjust if needed
                          } else if (constraints.maxWidth > 600) {
                            crossAxisCount = 2;
                            childAspectRatio = 1.5; // Increased from 1.4
                          }

                          return GridView.count(
                            crossAxisCount: crossAxisCount,
                            crossAxisSpacing: 16,
                            mainAxisSpacing: 18,
                            childAspectRatio: childAspectRatio,
                            shrinkWrap: true,
                            physics: const NeverScrollableScrollPhysics(), // Prevent GridView from scrolling independently
children: _configs.map((config) {
  final int id = config['id'] ?? 0;
  final String name = config['name'] ?? 'Unnamed POS';
  final String address = config['shop_addrs'] ?? 'Not set';
  final double cash = (config['last_session_closing_cash'] ?? 0.0).toDouble();
  final String shopGstNo = (config['shop_gst_no'] ?? 'Not set').toString();
  final String shopPhoneNo = config['shop_phone_no']?.toString() ?? '-';
  final String shopOwnerName = config['shop_owner_name'] ?? 'Unknown'; // fixed here
  final dynamic rawDate = config['last_session_closing_date'];
  final String date = (rawDate == false || rawDate == null || rawDate.toString() == 'false')
      ? 'N/A'
      : _formatDate(rawDate.toString());
 final dynamic sessionRaw = config['current_session_state'];
final int sessionInt = (sessionRaw is int)
    ? sessionRaw
    : int.tryParse(sessionRaw?.toString() ?? '') ?? 0;
final bool sessionState = sessionInt == 1;

  return _buildPOSConfigCard(
    id: id,
    name: name,
    address: address,
    cash: cash,
    shopGstNo: shopGstNo,
    shopPhoneNo: shopPhoneNo,
    shopOwnerName: shopOwnerName,
    date: date,
    sessionState: sessionState, // pass bool, not int
    specificConfig: config,
  );
}).toList(),
                         );
                        },
                      ),
                    ),
    );
  }

  // --- Widgets for Error and No Data States ---

  Widget _buildErrorWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, color: Colors.red.shade700, size: 80),
            const SizedBox(height: 20),
            Text(
              _errorMessage ?? 'An unknown error occurred.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: fetchPOSConfigs, // Allows user to retry fetching data
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Color(0xFF185A9D),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNoConfigsWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, color: Colors.blueGrey.shade400, size: 80),
            const SizedBox(height: 20),
            Text(
              'No POS configurations found.\nPlease check your Odoo setup or try refreshing.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: fetchPOSConfigs, // Allows user to refresh list
              icon: const Icon(Icons.refresh),
              label: const Text('Refresh'),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color.fromARGB(255, 1, 139, 82),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- Widget for an individual POS Configuration Card ---
  Widget _buildPOSConfigCard({
    required int id,
    required String name,
    required String address,
    required double cash,
    required String shopGstNo,
    required String shopPhoneNo,
    required String shopOwnerName,
    required String date,
    required dynamic sessionState,
    required Map<String, dynamic> specificConfig, // <-- NEW: Pass the actual config map here
  }) {
    return Card(
      elevation: 6, // Increased elevation for a floating effect
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
      child: Container(
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(15),
          border: Border.all(color: Colors.grey.shade200),
        ),
        padding: const EdgeInsets.all(18), // Slightly increased padding
        child: Stack(
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              // mainAxisSize: MainAxisSize.min, // Optional: if content seems too large and causes overflow, uncomment this.
              children: [
                Text(
                  name,
                  style: const TextStyle(
                    fontSize: 20, // Increased font size for name
                    fontWeight: FontWeight.w800, // Make it bolder
                    color: Color.fromARGB(255, 3, 0, 0),
                    fontFamily: 'Arial',
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis, // Prevents overflow of long names
                ),
                const SizedBox(height: 10), // Increased spacing
                _buildInfoText('Shop Incharge: ', shopOwnerName),
                const SizedBox(height: 6),
                _buildInfoText('Phone No: ', shopPhoneNo),
                const SizedBox(height: 6),
                _buildInfoText('Shop Address: ', address),
                const SizedBox(height: 6),
                _buildInfoText('Shop GST No: ', shopGstNo),
                const SizedBox(height: 6),
                _buildInfoText('Last Closing Cash: ', 'â‚¹${cash.toStringAsFixed(2)}'),
                const SizedBox(height: 6),
                _buildInfoText('Last Closing Date: ', date),
                // Fix: Removed Spacer() which was causing unbounded height errors in GridView context
                // Instead, a SizedBox is used for consistent spacing before the button.
                const SizedBox(height: 10),

Align(
  alignment: Alignment.bottomRight,
  child: ElevatedButton(
    style: ElevatedButton.styleFrom(
      backgroundColor: Color(0xFF2CA571),
      foregroundColor: Colors.white,
      padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      elevation: 4,
    ),
onPressed: () async {
  if (sessionState == true) {
    // Session already open, just navigate
Navigator.pushReplacement(
  context,
  MaterialPageRoute(
    builder: (_) => HomePage(
      posConfig: specificConfig,
      sessionState: sessionState is bool
          ? sessionState
          : (sessionState == 1),
      posId: specificConfig['id'] is int
          ? specificConfig['id']
          : int.tryParse(specificConfig['id'].toString()) ?? 0,
    ),
  ),
);

  } else {
    // Show dialog to open session
    final bool? opened = await showDialog<bool>(
      context: context,
      builder: (_) => OpenSessionDialog(
        sessionState: sessionState,
        posId: specificConfig['id'],
      ),
    );

    if (opened == true) {
      setState(() {
        final index = _configs.indexWhere((config) => config['id'] == specificConfig['id']);
        if (index != -1) {
          _configs[index]['current_session_state'] = 1; // Use 1 instead of true for consistency with int
        }
      });

      // Ideally also update the local DB session state here to persist change
      await posConfigSQLiteHelper.instance.updateSessionState(specificConfig['id'], 1);

      Navigator.pushReplacement(
        context,
        MaterialPageRoute(
          builder: (_) => HomePage(posConfig: _configs.firstWhere((c) => c['id'] == specificConfig['id'],
          ),sessionState: sessionState,
        posId: specificConfig['id'],),
        ),
      );
    }
    // if user canceled dialog or opened is false, do nothing (stay on page)
  }
},
  child: Text(
      sessionState ? "Continue Selling" : "Start Billing",
      style: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.bold,
        fontFamily: "Arial",
      ),
    ),
  ),
),
],
            ),
            // Positioned status tag at the top-right corner
            Positioned(
              top: 0,
              right: 0,
              child: Container(
                decoration: BoxDecoration(
                  color: getStatusColor(sessionState),
                  borderRadius: const BorderRadius.only(
                    topRight: Radius.circular(15), // Match card radius
                    bottomLeft: Radius.circular(15), // Match card radius
                  ),
                ),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6), // Slightly larger padding
                child: Text(
                  getStatusText(sessionState),
                  style: const TextStyle(color: Colors.white, fontSize: 13, fontFamily: 'Arial', fontWeight: FontWeight.w600),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- Helper for Info Text Rows ---
  Widget _buildInfoText(String label, String value) {
    return RichText(
      text: TextSpan(
        style: const TextStyle(
          fontSize: 15,
          fontFamily: 'Arial',
          fontWeight: FontWeight.w500,
          color: Color.fromARGB(185, 0, 0, 0),
        ),
        children: [
          TextSpan(
            text: label,
            style: const TextStyle(fontSize: 15, fontWeight: FontWeight.bold), // Adjusted font size here too
          ),
          TextSpan(text: value),
        ],
      ),
      maxLines: 1, // Crucial: Prevents overflow on small screens
      overflow: TextOverflow.ellipsis, // Shows "..." if text is too long
    );
  }
}



// file: posconfigpage.dart

import 'dart:convert';
import 'dart:io'; // For HttpHeaders
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/components/snackbar_helper.dart';
import 'package:rcspos/localdb/posconfigsqlitehelper.dart';

import 'package:rcspos/screens/home.dart'; // Make sure this path is correct
import 'package:rcspos/screens/loginpage.dart';

import 'package:rcspos/screens/open_session_dialog.dart';
import 'package:rcspos/screens/productpage.dart';
import 'package:rcspos/utils/urls.dart'; // Make sure baseurl is correctly defined here
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';


class POSConfigPage extends StatefulWidget {   

    const POSConfigPage({ 
    super.key,

  });

  @override
  State<POSConfigPage> createState() => _POSConfigPageState();
}

class _POSConfigPageState extends State<POSConfigPage> {
  
  bool _loading = true;
  List<Map<String, dynamic>> _configs = [];
  String? _errorMessage; // Added for specific error messages

  final String apiUrl =
      '$baseurl/api/pos.config/?query={id,name,shop_phone_no,shop_code,shop_addrs,last_session_closing_cash,last_session_closing_date,current_session_state,shop_gst_no,shop_phone_no,shop_owner_id{id,name}}';

  @override
  void initState() {
    super.initState();
    fetchPOSConfigs();
    
  }

Future<void> fetchPOSConfigs() async {
  setState(() {
    _loading = true;
    _errorMessage = null;
  });

  final box = await Hive.openBox('login');
  final sqlite = posConfigSQLiteHelper.instance;

  try {
    final rawSession = box.get('session_id');

    if (rawSession == null || (rawSession as String).trim().isEmpty) {
      showError('Session ID not found. Please login again.');
      return;
    }

    final sessionId = rawSession.startsWith('session_id=')
        ? rawSession
        : 'session_id=$rawSession';
    debugPrint('Using sessionId: $sessionId');

    final response = await http.get(
      Uri.parse(apiUrl),
      headers: {
        HttpHeaders.cookieHeader: sessionId,
        HttpHeaders.contentTypeHeader: 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      final List configsRaw = data['result'] ?? [];

      if (configsRaw.isEmpty) {
        showError("No POS configurations found in the API response.");
        setState(() => _configs = []);
        return;
      }

      final List<Map<String, dynamic>> parsedConfigs =
          configsRaw.map((e) => Map<String, dynamic>.from(e)).toList();

      // Insert or update local DB
      await sqlite.insertConfigs(parsedConfigs);

      // Fetch updated data from local DB
      final updatedConfigs = await sqlite.getAllConfigs();
      print("âœ… Number of configs fetched from DB: ${updatedConfigs.length}");
      for (var config in updatedConfigs) {
        print("ðŸ”¹ Config: $config");
      }

      setState(() {
        _configs = updatedConfigs;
      });
    } else {
      final error = jsonDecode(response.body);
      final msg = error['error']?['data']?['message'] ?? response.body;

      showError("API Error: ${response.statusCode} - $msg");

      final offlineData = await sqlite.getAllConfigs();
      if (offlineData.isNotEmpty) {
        setState(() => _configs = offlineData);
        showCustomSnackBar(
          context: context,
          title: "Using Offline Data",
          message: "Showing cached POS configurations.",
          backgroundColor: Colors.orange,
          icon: Icons.cloud_off,
        );
      } else {
        setState(() => _configs = []);
        showError("No offline POS configs available.");
      }
    }
  } catch (e, stackTrace) {
    debugPrint("âŒ Exception during fetch: $e\n$stackTrace");

    final offlineData = await sqlite.getAllConfigs();
    if (offlineData.isNotEmpty) {
      setState(() => _configs = offlineData);
      showCustomSnackBar(
        context: context,
        title: "Offline Mode",
        message: "API failed. Loaded local POS configs.",
        backgroundColor: Colors.orange,
        icon: Icons.wifi_off,
      );
    } else {
      setState(() => _configs = []);
      showError("Offline Fetch Failed: No local POS configs available.");
    }
  } finally {
    setState(() => _loading = false);
  }
}
  
  String _formatDate(String value) {
    try {
      final date = DateTime.tryParse(value);
      if (date != null) {
        return '${date.day.toString().padLeft(2, '0')}-${date.month.toString().padLeft(2, '0')}-${date.year}';
      }
    } catch (_) {
      // Handle parsing errors gracefully
    }
    return 'N/A';
  }
  // --- Error Message Handler ---
  void showError(String message) {
    setState(() {
      _loading = false;
      _errorMessage = message; // Store the error message
    });
    // Also show a SnackBar for immediate feedback
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message)));
  }

  // --- Status Color and Text Helpers ---
  Color getStatusColor(dynamic status) {
    if (status == true) return Colors.green.shade600; // Slightly darker green
    if (status == false) return Colors.red.shade600; // Slightly darker red
    return Colors.grey.shade600; // Consistent grey
  }

  String getStatusText(dynamic status) {
    if (status == true) return 'In Progress';
    if (status == false) return 'Closed';
    return 'Unknown';
  }

  // --- UI Build Method ---
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Point Of Sale',
          style: TextStyle(
            fontFamily: 'Arial',
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
         flexibleSpace: Container(
    decoration: const BoxDecoration(
      gradient: LinearGradient(
        colors: [Color.fromARGB(255, 44, 145, 113), Color(0xFF185A9D)],
        begin: Alignment.topLeft,
        end: Alignment.bottomRight,
      ),
    ),
  ),
        backgroundColor: Colors.transparent,
        iconTheme: const IconThemeData(color: Colors.white),
        actions: [
          IconButton(
            icon: const Icon(Icons.exit_to_app),
            tooltip: 'Logout',
            onPressed: () {
             
              Navigator.pushAndRemoveUntil(
                context,
                MaterialPageRoute(builder: (context) => const Login()), // Removed posConfig
                (route) => false,
              );

              
            },
          ),
        ],
      ),
      backgroundColor: const Color(0xFFF7F4FB),
      body: _loading
          ? const Center(child: CircularProgressIndicator())
          : _errorMessage != null // Show error widget if there's an error
              ? _buildErrorWidget()
              : _configs.isEmpty
                  ? _buildNoConfigsWidget() // Show no configs widget if list is empty
                  : SingleChildScrollView(
                      padding: const EdgeInsets.all(5),
                      child: Center(
                        child: SingleChildScrollView(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: _configs.map((config) {
                              final int id = config['id'] ?? 0;
                              final String name = config['name'] ?? 'Unnamed POS';
                              final String address = config['shop_addrs'] ?? 'Not set';
                              final double cash = (config['last_session_closing_cash'] ?? 0.0).toDouble();
                              final String shopGstNo = (config['shop_gst_no'] ?? 'Not set').toString();
                              final String shopPhoneNo = config['shop_phone_no']?.toString() ?? '-';
                              final String shopOwnerName = config['shop_owner_name'] ?? 'Unknown';
                              final dynamic rawDate = config['last_session_closing_date'];
                              final String date = (rawDate == false || rawDate == null || rawDate.toString() == 'false')
                                  ? 'N/A'
                                  : _formatDate(rawDate.toString());
                              final dynamic sessionRaw = config['current_session_state'];
                              final int sessionInt = (sessionRaw is int)
                                  ? sessionRaw
                                  : int.tryParse(sessionRaw?.toString() ?? '') ?? 0;
                              final bool sessionState = sessionInt == 1;

 return Padding(
  padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 16.0),
  
  child: Card(
    elevation: 4,
    
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(8),
    ),
    color: Colors.white,
    child: Stack(
      children: [
        // Blue background with curved bottom
        Container(
          height: 80,
          decoration: const BoxDecoration(
            color: Colors.blue,
            borderRadius: BorderRadius.only(
              bottomLeft: Radius.circular(40),
              bottomRight: Radius.circular(40),
            ),
          ),
        ), // or any background color you want
     Padding(
      
      padding: const EdgeInsets.all(12.0),
      
      child: _buildPOSConfigCard(
        id: id,
        name: name,
        address: address,
        cash: cash,
        shopGstNo: shopGstNo,
        shopPhoneNo: shopPhoneNo,
        shopOwnerName: shopOwnerName,
        date: date,
        sessionState: sessionState,
        specificConfig: config,
      ),
    ),
      ],
  ),

  ),
);
                           }).toList(),
                          ),
                        ),
                      ),
                    ),
    );
  }

  // --- Widgets for Error and No Data States ---

  Widget _buildErrorWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, color: Colors.red.shade700, size: 80),
            const SizedBox(height: 20),
            Text(
              _errorMessage ?? 'An unknown error occurred.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: fetchPOSConfigs, // Allows user to retry fetching data
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Color(0xFF185A9D),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNoConfigsWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, color: Colors.blueGrey.shade400, size: 80),
            const SizedBox(height: 20),
            Text(
              'No POS configurations found.\nPlease check your Odoo setup or try refreshing.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: fetchPOSConfigs, // Allows user to refresh list
              icon: const Icon(Icons.refresh),
              label: const Text('Refresh'),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color.fromARGB(255, 1, 139, 82),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

Widget _buildPOSConfigCard({
  required int id,
  required String name,
  required String address,
  required double cash,
  required String shopGstNo,
  required String shopPhoneNo,
  required String shopOwnerName,
  required String date,
  required dynamic sessionState,
  required Map<String, dynamic> specificConfig,
}) {
  return Center(
    child: Padding(
     padding: const EdgeInsets.symmetric(horizontal: 300.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // Logo + Shop Info
Stack(
  alignment: Alignment.topCenter,
  children: [
    // Navbar background behind the logo & info
    

    // Foreground content: logo + text
    Padding(
      padding: const EdgeInsets.only(top: 30.0), // adjust based on layout
      child: Row(
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          // Logo
Container(
  padding: const EdgeInsets.all(0), // Space inside the circle
  decoration: BoxDecoration(
    color: Colors.white,
    shape: BoxShape.circle,
    // border: Border.all(
    //   color: const Color.fromARGB(255, 130, 160, 165), // Border color
    //   width: 2.0, // Border thickness
    // ),
    boxShadow: [
      BoxShadow(
        color: Colors.grey.withOpacity(0.5), // Shadow color
        spreadRadius: 2,
        blurRadius: 8,
        offset: const Offset(0, 4), // Position of the shadow
      ),
    ],
  ),
  child: Image.asset(
    'assets/rcslogo.png',
    height: 100,
    fit: BoxFit.contain,
  ),
),

          const SizedBox(width: 12),

          // Text content
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                name,
                style: const TextStyle(
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                  fontFamily: 'Arial',
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                address,
                style: const TextStyle(
                  fontSize: 17,
                  fontWeight: FontWeight.w600,
                  fontFamily: 'Arial',
                  color: Colors.white70,
                ),
              ),
              Text(
                'Owner: $shopOwnerName',
                style: const TextStyle(
                  fontSize: 14,
                  fontFamily: 'Arial',
                  color: Colors.white,
                ),
              ),
              Text(
                'Phone: $shopPhoneNo',
                style: const TextStyle(
                  fontSize: 14,
                  fontFamily: 'Arial',
                  color: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    ),
  ],
),
         SizedBox(
  width: 700, // The width you want for your divider
  child: const Divider(
    thickness: 2,
    color: Color.fromARGB(151, 3, 1, 1),
  ),
),
const SizedBox(height: 20),
          // Order Summary + Total
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // ORDER SUMMARY
              Expanded(
                flex: 3,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                  
                    _buildOrderLine("Total Products", 1, 5.50),
                    _buildOrderLine("Total Credits", 2, 8.00),
                    _buildOrderLine("Total Sales", 1, null), // example without price
                   
                   
                  ],
                ),
              ),

              // TOTAL PRODUCTS
             
            ],
          ),

          const SizedBox(height: 20),

          // Optional: Footer Info
          Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
             
              Text(
                'GST No: $shopGstNo',
                style: const TextStyle(fontSize: 14, fontFamily: 'Arial'),
              ),
              Text(
                'Last Closed: $date',
                style: const TextStyle(fontSize: 14, fontFamily: 'Arial'),
              ),
            ],
          )
        ],
      ),
    ),
  );

}

Widget _buildOrderLine(String item, int qty, double? price) {
  IconData iconData;
  Color iconColor;
  Color iconBgColor;

  // Logic for assigning icons and colors
  if (item.toLowerCase().contains('product')) {
    iconData = Icons.inventory_2_rounded;
    iconColor = Colors.white;
    iconBgColor = Colors.green;
  } else if (item.toLowerCase().contains('credits')) {
    iconData = Icons.person;
    iconColor = Colors.white;
    iconBgColor = Colors.green;
  } else if (item.toLowerCase().contains('sales')) {
    iconData = Icons.shopping_cart;
    iconColor = Colors.white;
    iconBgColor = Colors.green;
  } else {
    iconData = Icons.info;
    iconColor = Colors.white;
    iconBgColor = Colors.grey;
  }

  // Icon inside a circle
  Widget iconCircle = Container(
    width: 40,
    height: 40,
    decoration: BoxDecoration(
      color: iconBgColor,
      shape: BoxShape.circle,
    ),
    child: Center(
      child: Icon(
        iconData,
        color: iconColor,
        size: 20,
      ),
    ),
  );

  return GestureDetector(
    onTap: () {
      if (item.toLowerCase().contains('total products')) {
        // Navigate to ProductPage
      } else if (item.toLowerCase().contains('total credits')) {
        // Navigate to CreditsPage
      } else if (item.toLowerCase().contains('total sales')) {
        // Navigate to SalesPage
      }
    },
    child: Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      margin: const EdgeInsets.symmetric(vertical: 6),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // Icon + text in a row
          Row(
            children: [
              iconCircle,
              const SizedBox(width: 12),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    item,
                    style: const TextStyle(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      fontFamily: 'Arial',
                      color: Color(0xFF4B4B7C),
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '$qty Sales',
                    style: const TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w400,
                      fontFamily: 'Arial',
                      color: Color(0xFF4B4B7C),
                    ),
                  ),
                ],
              ),
            ],
          ),
          // Arrow Icon
          const Icon(
            Icons.arrow_forward,
            color: Color.fromARGB(255, 29, 29, 29),
            size: 20,
          ),
        ],
      ),
    ),
  );
}

  // --- Helper for Info Text Rows ---
  Widget _buildInfoText(String label, String value) {
    return RichText(
      text: TextSpan(
        style: const TextStyle(
          fontSize: 15,
          fontFamily: 'Arial',
          fontWeight: FontWeight.w500,
          color: Color.fromARGB(185, 0, 0, 0),
        ),
        children: [
          TextSpan(
            text: label,
            style: const TextStyle(fontSize: 15, fontWeight: FontWeight.bold), // Adjusted font size here too
          ),
          TextSpan(text: value),
        ],
      ),
      maxLines: 1, // Crucial: Prevents overflow on small screens
      overflow: TextOverflow.ellipsis, // Shows "..." if text is too long
    );
  }
}




// file: posconfigpage.dart

import 'dart:convert';
import 'dart:io'; // For HttpHeaders
import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/components/snackbar_helper.dart';
import 'package:rcspos/localdb/posconfigsqlitehelper.dart';
import 'package:rcspos/screens/home.dart';
import 'package:rcspos/screens/loginpage.dart';
import 'package:rcspos/screens/open_session_dialog.dart';
import 'package:rcspos/screens/productpage.dart';
import 'package:rcspos/utils/urls.dart';
import 'package:awesome_snackbar_content/awesome_snackbar_content.dart';

class POSConfigPage extends StatefulWidget {
  const POSConfigPage({super.key});

  @override
  State<POSConfigPage> createState() => _POSConfigPageState();
}

class _POSConfigPageState extends State<POSConfigPage> {
  bool _loading = true;
  List<Map<String, dynamic>> _configs = [];
  String? _errorMessage;

  final String apiUrl =
      '$baseurl/api/pos.config/?query={id,name,shop_phone_no,shop_code,shop_addrs,last_session_closing_cash,last_session_closing_date,current_session_state,shop_gst_no,shop_owner_id{id,name}}';

  @override
  void initState() {
    super.initState();
    fetchPOSConfigs();
  }

  Future<void> fetchPOSConfigs() async {
    setState(() {
      _loading = true;
      _errorMessage = null;
    });

    final box = await Hive.openBox('login');
    final sqlite = posConfigSQLiteHelper.instance;

    try {
      final rawSession = box.get('session_id');

      if (rawSession == null || (rawSession as String).trim().isEmpty) {
        showError('Session ID not found. Please login again.');
        return;
      }

      final sessionId = rawSession.startsWith('session_id=')
          ? rawSession
          : 'session_id=$rawSession';

      final response = await http.get(
        Uri.parse(apiUrl),
        headers: {
          HttpHeaders.cookieHeader: sessionId,
          HttpHeaders.contentTypeHeader: 'application/json',
        },
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final List configsRaw = data['result'] ?? [];

        if (configsRaw.isEmpty) {
          showError("No POS configurations found in the API response.");
          setState(() => _configs = []);
          return;
        }

        final List<Map<String, dynamic>> parsedConfigs =
            configsRaw.map((e) => Map<String, dynamic>.from(e)).toList();

        await sqlite.insertConfigs(parsedConfigs);
        final updatedConfigs = await sqlite.getAllConfigs();

        setState(() {
          _configs = updatedConfigs;
        });
      } else {
        final error = jsonDecode(response.body);
        final msg = error['error']?['data']?['message'] ?? response.body;
        showError("API Error: ${response.statusCode} - $msg");

        final offlineData = await sqlite.getAllConfigs();
        if (offlineData.isNotEmpty) {
          setState(() => _configs = offlineData);
          showCustomSnackBar(
            context: context,
            title: "Using Offline Data",
            message: "Showing cached POS configurations.",
            backgroundColor: Colors.orange,
            icon: Icons.cloud_off,
          );
        } else {
          setState(() => _configs = []);
          showError("No offline POS configs available.");
        }
      }
    } catch (e, stackTrace) {
      debugPrint("âŒ Exception during fetch: $e\n$stackTrace");

      final offlineData = await sqlite.getAllConfigs();
      if (offlineData.isNotEmpty) {
        setState(() => _configs = offlineData);
        showCustomSnackBar(
          context: context,
          title: "Offline Mode",
          message: "API failed. Loaded local POS configs.",
          backgroundColor: Colors.orange,
          icon: Icons.wifi_off,
        );
      } else {
        setState(() => _configs = []);
        showError("No offline POS configs available.");
      }
    } finally {
      setState(() => _loading = false);
    }
  }

  void showError(String message) {
    setState(() {
      _loading = false;
      _errorMessage = message;
    });
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(message)));
  }

  // NOTE: These helper methods are no longer needed for the new UI but are kept for reference.
  Color getStatusColor(dynamic status) {
    if (status == true) return Colors.green.shade600;
    if (status == false) return Colors.red.shade600;
    return Colors.grey.shade600;
  }

  String getStatusText(dynamic status) {
    if (status == true) return 'In Progress';
    if (status == false) return 'Closed';
    return 'Unknown';
  }

  String _formatDate(String value) {
    try {
      final date = DateTime.tryParse(value);
      if (date != null) {
        return '${date.day.toString().padLeft(2, '0')}-${date.month.toString().padLeft(2, '0')}-${date.year}';
      }
    } catch (_) {
      // Handle parsing errors gracefully
    }
    return 'N/A';
  }

  @override
@override
Widget build(BuildContext context) {
  return Scaffold(
    backgroundColor: const Color(0xFFF4F6FA),
    appBar: AppBar(
      elevation: 1,
      backgroundColor: Colors.white,
      title: Row(
        children: [
          Image.asset('assets/rcslogo.png', width: 38, height: 38),
          const SizedBox(width: 12),
          const Text(
            'Point Of Sale',
            style: TextStyle(
              color: Color(0xFF17496D),
              fontWeight: FontWeight.bold,
              fontSize: 23,
            ),
          ),
        ],
      ),
      actions: [
        IconButton(icon: const Icon(Icons.account_circle_rounded, color: Colors.grey), onPressed: () {}),
        IconButton(icon: const Icon(Icons.logout, color: Colors.redAccent), onPressed: () {}),
      ],
    ),
    body: _loading
        ? const Center(child: CircularProgressIndicator())
        : _errorMessage != null
            ? _buildErrorWidget()
            : _configs.isEmpty
                ? _buildNoConfigsWidget()
                : LayoutBuilder(
                    builder: (context, constraints) => SingleChildScrollView(
                      padding: const EdgeInsets.symmetric(vertical: 22, horizontal: 16),
                      child: Center(
                        child: Container(
                          constraints: const BoxConstraints(maxWidth: 800),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Action cards row
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  _mainActionButton(
                                    icon: Icons.point_of_sale_rounded,
                                    label: "New Sale",
                                    color: Colors.green[700]!,
                                    onTap: () {},
                                  ),
                                  _mainActionButton(
                                    icon: Icons.receipt_long,
                                    label: "Transactions",
                                    color: Colors.indigo[700]!,
                                    onTap: () {},
                                  ),
                                  _mainActionButton(
                                    icon: Icons.inventory_2,
                                    label: "Products",
                                    color: Colors.orange[700]!,
                                    onTap: () {},
                                  ),
                                  _mainActionButton(
                                    icon: Icons.people_alt,
                                    label: "Customers",
                                    color: Colors.blueAccent[700]!,
                                    onTap: () {},
                                  ),
                                ],
                              ),
                              const SizedBox(height: 32),
                              
                              // Stat row
                              Row(
                                children: [
                                  _statCard("Total Sales", "24", Icons.attach_money, Colors.green),
                                  const SizedBox(width: 14),
                                  _statCard("Items Sold", "287", Icons.shopping_bag, Colors.blue),
                                  const SizedBox(width: 14),
                                  _statCard("Today Revenue", "â‚¹18,470", Icons.trending_up, Colors.deepPurple),
                                ],
                              ),
                              const SizedBox(height: 28),

                              // Config summary card (shows POS info)
                              _configSummaryCard(_configs.first),

                              // Recent activity
                              const Text(
                                "Recent Activity",
                                style: TextStyle(fontWeight: FontWeight.w700, fontSize: 19, color: Color(0xFF263146)),
                              ),
                              const SizedBox(height: 9),
                              // Replace with your real order data
                              _transactionListItem("INV-1023", "John Doe", "â‚¹2,300", "12:31 PM", "Paid"),
                              _transactionListItem("INV-1022", "Jane Smith", "â‚¹1,480", "12:14 PM", "Paid"),
                              _transactionListItem("INV-1021", "Walk-in", "â‚¹950", "11:50 AM", "Draft"),
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),

  );
}

Widget _configSummaryCard(Map<String, dynamic> config) {
  return Card(
    margin: const EdgeInsets.symmetric(vertical: 12),
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(13)),
    shadowColor: Colors.blueGrey[50],
    child: Padding(
      padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            config['name'] ?? 'POS Location',
            style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 17, color: Color(0xFF185A9D)),
          ),
          const SizedBox(height: 5),
          Row(
            children: [
              Icon(Icons.location_on, color: Colors.grey[400], size: 16),
              const SizedBox(width: 6),
              Expanded(
                child: Text(
                  config['shop_addrs'] ?? 'Not set',
                  style: const TextStyle(fontSize: 13.4, color: Colors.black87),
                  maxLines: 2, overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
          const SizedBox(height: 6),
          Row(
            children: [
              Icon(Icons.phone, color: Colors.grey[400], size: 15),
              const SizedBox(width: 5),
              Text(config['shop_phone_no']?.toString() ?? "-", style: const TextStyle(fontSize: 13)),
            ],
          ),
          const SizedBox(height: 3),
          Row(
            children: [
              Icon(Icons.person, color: Colors.grey[400], size: 15),
              const SizedBox(width: 5),
              Text(config['shop_owner_name'] ?? 'Unknown', style: const TextStyle(fontSize: 13)),
            ],
          ),
        ],
      ),
    ),
  );
}

  Widget _buildErrorWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, color: Colors.red.shade700, size: 80),
            const SizedBox(height: 20),
            Text(
              _errorMessage ?? 'An unknown error occurred.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(              onPressed: fetchPOSConfigs,
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF185A9D),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _mainActionButton({
  required IconData icon,
  required String label,
  required Color color,
  required VoidCallback onTap,
}) {
  return Expanded(
    child: GestureDetector(
      onTap: onTap,
      child: Container(
        height: 74,
        margin: const EdgeInsets.symmetric(horizontal: 7),
        decoration: BoxDecoration(
          color: color.withOpacity(0.10),
          border: Border.all(color: color.withOpacity(0.22), width: 1.1),
          borderRadius: BorderRadius.circular(18),
          boxShadow: [
            BoxShadow(
              color: color.withOpacity(0.07),
              blurRadius: 7,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, color: color, size: 31),
            const SizedBox(height: 8),
            Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.w600,
                fontSize: 15,
                color: color,
              ),
            ),
          ],
        ),
      ),
    ),
  );
}


  Widget _buildNoConfigsWidget() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, color: Colors.blueGrey.shade400, size: 80),
            const SizedBox(height: 20),
            Text(
              'No POS configurations found.\nPlease check your Odoo setup or try refreshing.',
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: Colors.grey.shade700,
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 30),
            ElevatedButton.icon(
              onPressed: fetchPOSConfigs,
              icon: const Icon(Icons.refresh),
              label: const Text('Refresh'),
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color.fromARGB(255, 1, 139, 82),
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
              ),
            ),
          ],
        ),
      ),
    );
  }

Widget _transactionListItem(
  String invoice,
  String customer,
  String amount,
  String time,
  String status,
) {
  Color statusColor = status == "Paid" ? Colors.green : Colors.orange[800]!;

  return Card(
    margin: const EdgeInsets.symmetric(vertical: 4),
    elevation: 0,
    child: ListTile(
      leading: Icon(Icons.receipt_long, color: Colors.blueGrey[400]),
      title: Text(
        invoice,
        style: const TextStyle(
          fontWeight: FontWeight.bold,
          fontSize: 15,
        ),
      ),
      subtitle: Text(
        "$customer   â€¢   $time",
        style: const TextStyle(fontSize: 13.4),
      ),
      trailing: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            amount,
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: Colors.indigo[800],
              fontSize: 15,
            ),
          ),
          Text(
            status,
            style: TextStyle(
              fontWeight: FontWeight.w700,
              fontSize: 12,
              color: statusColor,
            ),
          ),
        ],
      ),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(10),
        side: BorderSide(color: Colors.grey[200]!),
      ),
    ),
  );
}
Widget _statCard(String label, String value, IconData icon, Color color) {
  return Expanded(
    child: Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(13),
        border: Border.all(color: color.withOpacity(0.17), width: 1),
        boxShadow: [
          BoxShadow(
            color: color.withOpacity(0.08),
            blurRadius: 17,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(7),
            decoration: BoxDecoration(
              color: color.withOpacity(0.15),
              shape: BoxShape.circle,
            ),
            child: Icon(icon, color: color, size: 22),
          ),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                value,
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  fontSize: 20,
                  color: color,
                ),
              ),
              Text(
                label,
                style: const TextStyle(
                  fontSize: 13.5,
                  color: Colors.black87,
                  fontWeight: FontWeight.w400,
                ),
              ),
            ],
          ),
        ],
      ),
    ),
  );
}

}\





create customer

import 'dart:convert';
import 'dart:io';
import 'package:flutter/material.dart';
import 'dart:async';

import 'package:flutter/services.dart';
import 'package:hive/hive.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:http/http.dart' as http;
import 'package:rcspos/components/snackbar_helper.dart';
import 'package:rcspos/data/customerdata.dart';
import 'package:rcspos/localdb/customersqlitehelper.dart';
import 'package:rcspos/screens/customerpage.dart';
import 'package:rcspos/utils/urls.dart'; // Ensure this path is correct

class CreateCustomerPage extends StatefulWidget {
  const CreateCustomerPage({super.key});

  @override
  State<CreateCustomerPage> createState() => _CreateCustomerPageState();
}

class _CreateCustomerPageState extends State<CreateCustomerPage> {
  late final Customersqlitehelper customerHelper;
  // No need for _customerDB if customerHelper is the instance
  // final _customerDB = Customersqlitehelper.instance; // Keep this if you prefer, but customerHelper is the same

  final _formKey = GlobalKey<FormState>();
  final nameController = TextEditingController();
  final phoneController = TextEditingController();
  final emailController = TextEditingController();
  final contactAddressController = TextEditingController();
  final street2Controller = TextEditingController();
  final cityController = TextEditingController();
  final zipController = TextEditingController();
  final vatController = TextEditingController(); // For GSTIN
  bool isLoading = false;
  // New controllers for credit request
  final creditDaysController = TextEditingController();
  final creditAmountController = TextEditingController();
  final reasonController = TextEditingController();

  String _selectedType = 'person';
  bool _createCreditRequest = false;
  bool _isSaving = false;


 

@override
void initState() {
  super.initState();

  customerHelper = Customersqlitehelper.instance;
   

}
 




  @override
  void dispose() {
   
 
    nameController.dispose();
    phoneController.dispose();
    emailController.dispose();
    contactAddressController.dispose();
    street2Controller.dispose();
    cityController.dispose();
    zipController.dispose();
    vatController.dispose(); // Dispose GST controller
    creditDaysController.dispose();
    creditAmountController.dispose();
    reasonController.dispose();
    super.dispose();
  }


  Future<bool> _createCustomer(Map<String, dynamic> customerData) async {
    try {
      final localId = await customerHelper.insertLocalCustomer(customerData);
      debugPrint('âœ… Customer created locally with ID: $localId');
      return true;
    } catch (e) {
      debugPrint('âŒ Error creating customer locally: $e');
      return false;
    }
  }
Future<void> _syncUnsyncedCustomers() async {
  final unsyncedCustomers = customerHelper.fetchUnsyncedCustomers();

  if (unsyncedCustomers.isEmpty) {
    debugPrint('No unsynced customers to upload.');
    return;
  }

  final List<Map<String, dynamic>> payload = unsyncedCustomers.map((customer) {
    final customerData = Map<String, dynamic>.from(customer);
    customerData.remove('id');
    if (customerData['phone'] is String && customerData['phone'].isNotEmpty) {
      try {
        customerData['phone'] = int.parse(customerData['phone']);
      } catch (e) {
        debugPrint('Error parsing phone number for customer: ${customerData['name']}');
      }
    }
    return customerData;
  }).toList();
  
  debugPrint('Payload being sent to server: ${jsonEncode(payload)}');

  final box = await Hive.openBox('login');
  final sessionId = box.get('session_id');
  if (sessionId == null) {
    debugPrint('âŒ No session ID available for syncing customers.');
    return;
  }

  try {
    final response = await http.post(
      Uri.parse('$baseurl/mobile/create_customers'),
      headers: {
        HttpHeaders.cookieHeader: sessionId,
        HttpHeaders.contentTypeHeader: 'application/json',
      },
      body: jsonEncode(payload),
    );

    debugPrint('Server responded with Status Code: ${response.statusCode}');
    debugPrint('Server Response Body: ${response.body}');

    if (response.statusCode == 200) {
      final List<dynamic> responseJson = json.decode(response.body);

      if (responseJson.isNotEmpty && responseJson.first is Map && responseJson.first.containsKey('id')) {
        debugPrint('âœ… All unsynced customers synced successfully.');
        for (final customerResponse in responseJson) {
          final int? localId = customerResponse['local_id'];
          final int? remoteId = customerResponse['id'];

          if (localId != null && remoteId != null) {
            await customerHelper.markCustomerAsSynced(localId, remoteId);
          }
        }
      } else {
        debugPrint('âŒ Sync failed despite 200 OK. Server response was invalid.');
      }
    } else {
      final responseBody = json.decode(response.body);
      final errorMessage = responseBody['error']['message'] ?? 'Unknown server error.';
      debugPrint('âŒ Failed to sync customers. Status code: ${response.statusCode}');
      debugPrint('Server Error: $errorMessage');
    }
  } catch (e) {
    debugPrint('âŒ Error during bulk customer sync: $e');
  }
}
  List<Map<String, String>> tamilNaduDistricts = [
    {'district': 'Ariyalur', 'state': 'Tamil Nadu'},
    {'district': 'Chengalpattu', 'state': 'Tamil Nadu'},
    {'district': 'Chennai', 'state': 'Tamil Nadu'},
    {'district': 'Coimbatore', 'state': 'Tamil Nadu'},
    {'district': 'Cuddalore', 'state': 'Tamil Nadu'},
    {'district': 'Dharmapuri', 'state': 'Tamil Nadu'},
    {'district': 'Dindigul', 'state': 'Tamil Nadu'},
    {'district': 'Erode', 'state': 'Tamil Nadu'},
    {'district': 'Kallakurichi', 'state': 'Tamil Nadu'},
    {'district': 'Kanchipuram', 'state': 'Tamil Nadu'},
    {'district': 'Kanyakumari', 'state': 'Tamil Nadu'},
    {'district': 'Karur', 'state': 'Tamil Nadu'},
    {'district': 'Krishnagiri', 'state': 'Tamil Nadu'},
    {'district': 'Madurai', 'state': 'Tamil Nadu'},
    {'district': 'Mayiladuthurai', 'state': 'Tamil Nadu'},
    {'district': 'Nagapattinam', 'state': 'Tamil Nadu'},
    {'district': 'Namakkal', 'state': 'Tamil Nadu'},
    {'district': 'Nilgiris', 'state': 'Tamil Nadu'},
    {'district': 'Perambalur', 'state': 'Tamil Nadu'},
    {'district': 'Pudukkottai', 'state': 'Tamil Nadu'},
    {'district': 'Ramanathapuram', 'state': 'Tamil Nadu'},
    {'district': 'Ranipet', 'state': 'Tamil Nadu'},
    {'district': 'Salem', 'state': 'Tamil Nadu'},
    {'district': 'Sivaganga', 'state': 'Tamil Nadu'},
    {'district': 'Tenkasi', 'state': 'Tamil Nadu'},
    {'district': 'Thanjavur', 'state': 'Tamil Nadu'},
    {'district': 'Theni', 'state': 'Tamil Nadu'},
    {'district': 'Thoothukudi', 'state': 'Tamil Nadu'},
    {'district': 'Tiruchirappalli', 'state': 'Tamil Nadu'},
    {'district': 'Tirunelveli', 'state': 'Tamil Nadu'},
    {'district': 'Tirupathur', 'state': 'Tamil Nadu'},
    {'district': 'Tiruppur', 'state': 'Tamil Nadu'},
    {'district': 'Tiruvallur', 'state': 'Tamil Nadu'},
    {'district': 'Tiruvannamalai', 'state': 'Tamil Nadu'},
    {'district': 'Tiruvarur', 'state': 'Tamil Nadu'},
    {'district': 'Vellore', 'state': 'Tamil Nadu'},
    {'district': 'Viluppuram', 'state': 'Tamil Nadu'},
    {'district': 'Virudhunagar', 'state': 'Tamil Nadu'},
  ];

  Map<String, String>? selectedDistrict;

  final TextEditingController districtController = TextEditingController();
  final TextEditingController pincodeController = TextEditingController();

  // REMOVED: _saveCustomer is not directly called by _onCreatePressed anymore
  // and its logic is largely merged into _createCustomer.

  Widget _buildTextField(
    TextEditingController controller,
    String labelText,
    IconData icon, {
    String? hintText,
    TextInputType keyboardType = TextInputType.text,
    int? maxLength,
    int? maxLines,
    List<TextInputFormatter>? inputFormatters,
    String? Function(String?)? validator,
    bool required = false,
    bool enabled = true,
  }) {
    return TextFormField(
      controller: controller,
      keyboardType: keyboardType,
      maxLength: maxLength,
      inputFormatters: inputFormatters,
      enabled: enabled,
      decoration: InputDecoration(
        labelText: labelText,
        hintText: hintText,
        border: const OutlineInputBorder(),
        prefixIcon: Icon(icon),
        counterText: maxLength != null ? '' : null,
        labelStyle: const TextStyle(fontFamily: 'Arial'),
        hintStyle: const TextStyle(fontFamily: 'Arial'),
        errorStyle: const TextStyle(fontFamily: 'Arial'),
      ),
      validator: (v) {
        if (required && (v == null || v.trim().isEmpty)) {
          return '$labelText is required';
        }
        if (validator != null) {
          return validator(v);
        }
        return null;
      },
      style: const TextStyle(fontFamily: 'Arial'),
      autovalidateMode: (validator != null || required)
          ? AutovalidateMode.onUserInteraction
          : AutovalidateMode.disabled,
    );
  }

  List<Widget> _buildCompanyFields({bool isMobile = false, bool? leftColumn}) {
    List<Widget> fields = [];
    if (isMobile) {
      fields = [
        _buildTextField(contactAddressController, 'Contact Address', Icons.location_on,
            hintText: 'Building, Street, Area', required: true),
        const SizedBox(height: 10),
        _buildTextField(street2Controller, 'Street (optional)', Icons.meeting_room,
            hintText: 'Street'),
        const SizedBox(height: 10),
        DropdownButtonFormField<Map<String, String>>(
          value: selectedDistrict,
          items: tamilNaduDistricts.map((districtData) {
            final displayName = '${districtData['district']}, ${districtData['state']}';
            return DropdownMenuItem<Map<String, String>>(
              value: districtData,
              child: Text(displayName),
            );
          }).toList(),
          onChanged: (value) {
            setState(() {
              selectedDistrict = value;
              cityController.text = '${value?['district']}, ${value?['state']}';
            });
          },
          decoration: const InputDecoration(
            labelText: 'District',
            prefixIcon: Icon(Icons.location_city),
            hintText: 'e.g., Chennai, Tamil Nadu',
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 10),
        _buildTextField(zipController, 'ZIP', Icons.local_post_office,
            keyboardType: TextInputType.number,
            maxLength: 6,
            inputFormatters: [FilteringTextInputFormatter.digitsOnly],
            validator: (v) {
              if (v == null || v.trim().isEmpty) return 'ZIP is required';
              if (v.trim().length != 6) return 'ZIP must be 6 digits';
              return null;
            },
            required: true),
        const SizedBox(height: 10),
        _buildTextField(vatController, 'VAT / GSTIN (optional)', Icons.confirmation_number,
            hintText: 'Enter VAT/GSTIN number'),
      ];
    } else {
      if (leftColumn == true) {
        fields = [
          _buildTextField(contactAddressController, 'Contact Address', Icons.location_on,
              hintText: 'Building, Street, Area', required: true),
          const SizedBox(height: 10),
          DropdownButtonFormField<Map<String, String>>(
            value: selectedDistrict,
            items: tamilNaduDistricts.map((districtData) {
              final displayName = '${districtData['district']}, ${districtData['state']}';
              return DropdownMenuItem<Map<String, String>>(
                value: districtData,
                child: Text(displayName),
              );
            }).toList(),
            onChanged: (value) {
              setState(() {
                selectedDistrict = value;
                cityController.text = '${value?['district']}, ${value?['state']}';
              });
            },
            decoration: const InputDecoration(
              labelText: 'District',
              prefixIcon: Icon(Icons.location_city),
              hintText: 'e.g., Chennai, Tamil Nadu',
              border: OutlineInputBorder(),
            ),
          )
        ];
      } else {
        fields = [
          _buildTextField(street2Controller, 'Street (optional)', Icons.meeting_room,
              hintText: 'Street'),
          const SizedBox(height: 10),
          _buildTextField(zipController, 'ZIP', Icons.local_post_office,
              keyboardType: TextInputType.number,
              maxLength: 6,
              inputFormatters: [FilteringTextInputFormatter.digitsOnly],
              validator: (v) {
                if (v == null || v.trim().isEmpty) return 'ZIP is required';
                if (v.trim().length != 6) return 'ZIP must be 6 digits';
                return null;
              },
              required: true),
        ];
      }
    }
    return fields;
  }



  // Removed redundant _showSnackBar method - using snackbar_helper instead

  // REMOVED: _syncSingleCustomer is no longer needed with bulk upload strategy.

void _onCreatePressed() async {
  if (!_formKey.currentState!.validate()) {
    Scrollable.ensureVisible(
      _formKey.currentContext!,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeIn,
      alignment: 0.5,
    );
    return;
  }

  final name = nameController.text.trim();

  final confirmed = await showDialog<bool>(
    context: context,
    builder: (ctx) => AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      contentPadding: const EdgeInsets.fromLTRB(24, 20, 24, 10),
      title: Column(
        children: const [
          Icon(Icons.help_outline, size: 48, color: Color(0xFF018B52)),
          SizedBox(height: 10),
          Text(
            'Confirmation',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontFamily: 'Arial',
              fontWeight: FontWeight.bold,
              fontSize: 20,
              color: Color(0xFF018B52),
            ),
          ),
        ],
      ),
      content: Text(
        'Are you sure you want to create Customer "$name"?',
        textAlign: TextAlign.center,
        style: const TextStyle(fontFamily: 'Arial', fontSize: 16),
      ),
      actionsAlignment: MainAxisAlignment.center,
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(ctx, false),
          style: TextButton.styleFrom(
            foregroundColor: Colors.grey[700],
            textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16),
          ),
          child: const Text('Cancel'),
        ),
        ElevatedButton.icon(
          icon: const Icon(Icons.check_circle_outline),
          label: const Text('Yes, Create'),
          onPressed: () => Navigator.pop(ctx, true),
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF018B52),
            foregroundColor: Colors.white,
            textStyle: const TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
        ),
      ],
    ),
  );

  if (confirmed != true) return;

  String fullAddress = [
    contactAddressController.text.trim(),
    street2Controller.text.trim(),
    cityController.text.trim(),
    zipController.text.trim()
  ].where((part) => part.isNotEmpty).join(', ');

  final newCustomerData = {
    'name': name.trim(),
    'phone': phoneController.text.trim().toString(),
    'email': emailController.text.trim().isNotEmpty ? emailController.text.trim() : null,
    'company_type': _selectedType,
    'contact_address': fullAddress,
    if (_selectedType == 'company' && vatController.text.trim().isNotEmpty)
      'gst_number': vatController.text.trim(),

    if (_createCreditRequest) ...{
      'create_credit_request': 'true',
      'req_credit_days': creditDaysController.text.trim(),
      'req_credit_amount': creditAmountController.text.trim(),
      'reason': reasonController.text.trim(),
    }
  };
  debugPrint('Attempting to create customer locally with: $newCustomerData');

  final localSuccess = await _createCustomer(newCustomerData);

 if (localSuccess) {
    // debugPrint('âœ… Customer created locally with ID: $localId');
    final connectivityResult = await (Connectivity().checkConnectivity());

    // Call the bulk sync function instead of a single sync.
    if (connectivityResult.isNotEmpty && !connectivityResult.contains(ConnectivityResult.none)) {
      debugPrint('Device is online. Attempting to sync all unsynced customers.');
      await _syncUnsyncedCustomers();
    }
  }

  showDialog(
    context: context,
    barrierDismissible: false,
    builder: (ctx) => AlertDialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      contentPadding: const EdgeInsets.fromLTRB(24, 20, 24, 10),
      title: Column(
        children: [
          Icon(
            localSuccess ? Icons.check_circle_outline : Icons.error_outline,
            size: 48,
            color: localSuccess ? const Color(0xFF018B52) : Colors.red,
          ),
          const SizedBox(height: 10),
          Text(
            localSuccess ? 'Customer Created' : 'Creation Failed',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontFamily: 'Arial',
              fontWeight: FontWeight.bold,
              fontSize: 20,
              color: localSuccess ? const Color(0xFF018B52) : Colors.red,
            ),
          ),
        ],
      ),
      content: Text(
        localSuccess
            ? 'Customer "$name" has been created locally and queued for sync.'
            : 'Failed to create customer "$name" locally. Please try again.',
        textAlign: TextAlign.center,
        style: const TextStyle(fontFamily: 'Arial', fontSize: 16),
      ),
      actionsAlignment: MainAxisAlignment.center,
      actions: [
        TextButton(
          onPressed: () {
            Navigator.pop(ctx);
            if (localSuccess) {
              Navigator.pop(context, true);
            }
          },
          style: TextButton.styleFrom(
            foregroundColor: localSuccess ? const Color(0xFF018B52) : Colors.red,
            textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16, fontWeight: FontWeight.bold),
          ),
          child: const Text('OK'),
        ),
      ],
    ),
  );
}
  @override
  Widget build(BuildContext context) {
    final isMobile = MediaQuery.of(context).size.width < 600;

    return AlertDialog(
      insetPadding: const EdgeInsets.all(0),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 0,
      title: const Text(
        'Create New Customer',
        textAlign: TextAlign.center,
        style: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.bold,
          color: Color.fromARGB(255, 9, 2, 110),
          fontFamily: 'Arial',
        ),
      ),
      content: SizedBox(
        width: isMobile ? double.maxFinite : 650,
        child: SingleChildScrollView(
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 10),

                // Customer Type Selection
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Customer Type:',
                      style: TextStyle(
                        fontFamily: 'Arial',
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: Colors.black87,
                      ),
                    ),
                    Row(
                      children: [
                        Expanded(
                          child: RadioListTile<String>(
                            title: const Text('Person', style: TextStyle(fontFamily: 'Arial')),
                            value: 'person',
                            groupValue: _selectedType,
                            onChanged: (value) {
                              setState(() {
                                _selectedType = value!;
                                // Clear company-specific fields when switching to 'person'
                                contactAddressController.clear();
                                street2Controller.clear();
                                cityController.clear();
                                zipController.clear();
                                vatController.clear(); // Clear GST
                              });
                            },
                            activeColor: const Color.fromARGB(255, 1, 139, 82),
                          ),
                        ),
                        Expanded(
                          child: RadioListTile<String>(
                            title: const Text('Company', style: TextStyle(fontFamily: 'Arial')),
                            value: 'company',
                            groupValue: _selectedType,
                            onChanged: (value) {
                              setState(() {
                                _selectedType = value!;
                              });
                            },
                            activeColor: const Color.fromARGB(255, 1, 139, 82),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 10),

                // Basic Customer Info
                _buildTextField(nameController, 'Full Name', Icons.person,
                    hintText: 'Enter customer\'s full name', required: true),
                const SizedBox(height: 10),
                _buildTextField(phoneController, 'Phone Number', Icons.phone,
                    keyboardType: TextInputType.phone,
                    maxLength: 10,
                    inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                    validator: (v) {
                      if (v == null || v.trim().isEmpty) return 'Phone number is required';
                      if (v.length != 10) return 'Must be exactly 10 digits';
                      return null;
                    },
                    hintText: 'e.g., 9876543210 (10 digits)', required: true),
                const SizedBox(height: 10),
                _buildTextField(emailController, 'Email (optional)', Icons.email,
                    keyboardType: TextInputType.emailAddress,
                    inputFormatters: [FilteringTextInputFormatter.allow(RegExp(r'[a-zA-Z0-9@._\-]'))],
                    validator: (v) {
                      final t = v?.trim() ?? '';
                      if (t.isEmpty) return null;
                      final pattern = r'^[\w.\-]+@([\w\-]+\.)+[\w]{2,4}$';
                      return RegExp(pattern).hasMatch(t) ? null : 'Enter a valid email';
                    },
                    hintText: 'e.g., customer@example.com'),

                // Company-specific fields
                if (_selectedType == 'company') ...[
                  const SizedBox(height: 10),
                  isMobile
                      ? Column(
                          children: _buildCompanyFields(isMobile: true),
                        )
                      : Column(
                          children: [
                            Row(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Expanded(child: Column(children: _buildCompanyFields(leftColumn: true))),
                                const SizedBox(width: 16),
                                Expanded(child: Column(children: _buildCompanyFields(leftColumn: false))),
                              ],
                            ),
                            const SizedBox(height: 10),
                            _buildTextField(vatController, 'VAT / GSTIN (optional)', Icons.confirmation_number,
                                hintText: 'Enter VAT/GSTIN number'),
                          ],
                        ),
                ],

                // --- Credit Request Section ---

                CheckboxListTile(
                  title: const Text(
                    'Request Credit',
                    style: TextStyle(
                      fontFamily: 'Arial',
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: Colors.black87,
                    ),
                  ),
                  value: _createCreditRequest,
                  onChanged: (bool? value) {
                    setState(() {
                      _createCreditRequest = value!;
                      // Clear credit fields when checkbox is unchecked
                      if (!_createCreditRequest) {
                        creditDaysController.clear();
                        creditAmountController.clear();
                        reasonController.clear();
                      }
                    });
                  },
                  activeColor: const Color.fromARGB(255, 1, 139, 82),
                  checkColor: Colors.white,
                  contentPadding: EdgeInsets.zero,
                ),

                if (_createCreditRequest) ...[
                  const SizedBox(height: 1),
                  _buildTextField(
                    creditDaysController,
                    'Credit Days',
                    Icons.calendar_month,
                    keyboardType: TextInputType.number,
                    inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                    hintText: 'e.g., 30, 60, 90',
                    validator: (v) {
                      if (_createCreditRequest && (v == null || v.trim().isEmpty)) {
                        return 'Credit Days are required';
                      }
                      if (v != null && v.isNotEmpty && int.tryParse(v) == null) {
                        return 'Enter a valid number of days';
                      }
                      return null;
                    },
                    required: true,
                  ),
                  const SizedBox(height: 10),
                  _buildTextField(
                    creditAmountController,
                    'Credit Amount',
                    Icons.currency_rupee,
                    keyboardType: TextInputType.number,
                    inputFormatters: [FilteringTextInputFormatter.digitsOnly],
                    hintText: 'e.g., 50000',
                    validator: (v) {
                      if (_createCreditRequest && (v == null || v.trim().isEmpty)) {
                        return 'Credit Amount is required';
                      }
                      if (v != null && v.isNotEmpty && double.tryParse(v) == null) {
                        return 'Enter a valid amount';
                      }
                      return null;
                    },
                    required: true,
                  ),
                  const SizedBox(height: 10),
                  _buildTextField(
                    reasonController,
                    'Reason for Credit Request',
                    Icons.info_outline,
                    hintText: 'e.g., New corporate account, long-term client',
                    keyboardType: TextInputType.multiline,
                    maxLength: 200,
                    maxLines: 3,
                    validator: (v) {
                      if (_createCreditRequest && (v == null || v.trim().isEmpty)) {
                        return 'Reason is required for credit request';
                      }
                      return null;
                    },
                    required: true,
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
      actionsPadding: const EdgeInsets.fromLTRB(28, 0, 28, 28),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          style: TextButton.styleFrom(
            foregroundColor: Colors.grey[700],
            textStyle: const TextStyle(fontFamily: 'Arial', fontSize: 16),
          ),
          child: const Text('Cancel', style: TextStyle(fontFamily: 'Arial')),
        ),
        const SizedBox(width: 12),
        ElevatedButton.icon(
          icon: const Icon(Icons.add_circle_outline),
          label: const Text('Create', style: TextStyle(fontFamily: 'Arial', fontWeight: FontWeight.bold)),
          onPressed: _onCreatePressed,
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color.fromARGB(255, 1, 139, 82),
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          ),
        ),
      ],
    );
  }
}